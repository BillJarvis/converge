// Copyright (c) 2003-2006 King's College London, created by Laurence Tratt
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.


import Builtins, File, Functional, Strings
import Compiler_Vars, ITree




_EXPRS := [ITree::IClass_Def, ITree::IFunc_Def, ITree::IIf, ITree::INDIf, ITree::IVar, ITree::IImport, ITree::IWhile, ITree::IFor, ITree::IInt, ITree::IString, ITree::ISlot_Lookup, ITree::IModule_Lookup, ITree::IList, ITree::IDict, ITree::ISet, ITree::IApplication, ITree::IGet, ITree::ISlice, ITree::IEXBI, ITree::IReturn, ITree::IYield, ITree::IRaise, ITree::IAssert, ITree::IBreak, ITree::IContinue, ITree::IConjunction, ITree::IAlternation, ITree::IAssignment, ITree::INot, ITree::IBinary, ITree::IComparison, ITree::IInsert, ITree::IStandard_Quasi_Quotes, ITree::IOriginal_Name]




class ITree_TC:

	func tc(itree):
	
		self._indent_level := 0
		
		return self._preorder(itree)



	func _type_error(parent_node, part, node, should_be):
	
		type_error(parent_node.instance_of.name, part, node, should_be, parent_node.src_infos)



	func _check_expr(parent_node, part, node):
	
		for elem_class := _EXPRS.iterate():
			if elem_class.instantiated(node):
				break
		exhausted:
			self._type_error(parent_node, part, node, "IExpr")
		
		self._preorder(node)



	func _check_expr_block(parent_node, part, node):
	
		if not Builtins::List.conformed_by(node.exprs):
			self._type_error(node, "exprs", node.exprs, "List")
		
		for i := 0.to(node.exprs.len()):
			expr := node.exprs[i]
			if ITree::IPass.instantiated(expr):
				continue
			self._check_expr(node, Strings::format("%s[%d]", part, i), expr)



	////////////////////////////////////////////////////////////////////////////////////////////////
	// Traversal
	//


	func _preorder(node):
	
		return self.get_slot("_t_" + node.instance_of.name.to_lower_case())(node)



	func _t_imodule(node):

		if not Builtins::String.instantiated(node.module_name):
			self._type_error(node, "module_name", node.module_name, "String")

		if not Builtins::List.conformed_by(node.definitions):
			self._type_error(node, "definitions", node.definitions, "List")
		
		for definition := node.definitions.iterate():
			self._preorder(definition)



	func _t_iclass_def(node):

		if not Builtins::String.instantiated(node.class_name):
			self._type_error(node, "class_name", node.class_name, "String")

		if not Builtins::List.conformed_by(node.supers):
			self._type_error(node, "supers", node.supers, "List")
		for i := 0.to(node.supers.len()):
			self._check_expr(node, Strings::format("supers[%d]", i), node.supers[i])
		
		if not node.metaclass_ is null:
			self._check_expr(node, "metaclass", node.metaclass_)

		if not Builtins::List.conformed_by(node.fields):
			self._type_error(node, "fields", node.fields, "List")
		for i := 0.to(node.fields.len()):
			field := node.fields[i]
			if not (ITree::IAssignment.instantiated(field) | ITree::IFunc_Def.instantiated(field) | ITree::IClass_Def.instantiated(field)):
				self._type_error(node, Strings::format("fields[%d]", i), field, "[IAssignment, IFunc_Def, IClass_Def]")




	
	func _t_ifunc_def(node):
	
		if not (node.is_bound == 0 | node.is_bound == 1):
			raise "XXX"
		
		if not (Builtins::String.instantiated(node.func_name) | ITree::IInsert.instantiated(node.func_name)):
			self._type_error(node, "func_name", node.func_name, "[String, IInsert]")
		
		if not Builtins::List.conformed_by(node.params):
			self._type_error(node, "params", node.params, "List")
		for i := 0.to(node.params.len()):
			param := node.params[i]
			if not (ITree::IParam.instantiated(param) | ITree::IInsert.instantiated(param)):
				self._type_error(node, Strings::format("param[%d]", i), param, "[IParam, IInsert]")
			
		if not node.var_arg is null:
			if not ITree::IVar.instantiated(node.var_arg):
				self._type_error(node, "var_arg", node.var_arg, "IVar")

		if not Builtins::List.conformed_by(node.nonlocals):
			self._type_error(node, "nonlocals", node.nonlocals, "List")
		for i := 0.to(node.nonlocals.len()):
			nonlocal_ := node.nonlocals[i]
			if not ITree::IVar.instantiated(nonlocal_):
				self._type_error(node, Strings::format("nonlocal[%s]", i), nonlocal_, "IVar")

		if not Builtins::List.conformed_by(node.renames):
			self._type_error(node, "renames", node.renames, "List")
		for i := 0.to(node.renames.len()):
			raise "XXX"
		
		self._check_expr_block(node, "body", node.body)



	func _t_iif(node):

		for clause := node.clauses.iterate():
			if not ITree::IClause.instantiated(clause):
				self._type_error(node, "clause", clause, "IClause")
		
		if not node.else_body is null:
			self._check_expr_block(node, "else body", node.else_body)



	func _t_indif(node):

		for clause := node.clauses.iterate():
			if not ITree::IClause.instantiated(clause):
				self._type_error(node, "clause", clause, "IClause")



	func _t_ivar(node):
	
		pass



	func _t_iimport(node):
	
		if not Builtins::String.instantiated(node.module_path):
			self._type_error(node, "module_path", node.module_path, "String")



	func _t_iwhile(node):
	
		self._check_expr(node, "condition", node.condition)
		if not node.body is null:
			self._check_expr_block(node, "body", node.body)
		if not node.exhausted_body is null:
			self._check_expr_block(node, "exhausted_body", node.exhausted_body)
		if not node.broken_body is null:
			self._check_expr_block(node, "broken_body", node.broken_body)



	func _t_ifor(node):
	
		self._check_expr(node, "condition", node.condition)
		if not node.body is null:
			self._check_expr_block(node, "body", node.body)
		if not node.exhausted_body is null:
			self._check_expr_block(node, "exhausted_body", node.exhausted_body)
		if not node.broken_body is null:
			self._check_expr_block(node, "broken_body", node.broken_body)



	func _t_iint(node):

		if not Builtins::Int.instantiated(node.val):
			self._type_error(node, "value", node.val, "Int")



	func _t_istring(node):

		if not Builtins::String.instantiated(node.string):
			self._type_error(node, "value", node.string, "String")



	func _t_islot_lookup(node):
	
		self._check_expr(node, "object_expr", node.object_expr)
		
		if not Builtins::String.instantiated(node.slot_name):
			self._type_error(node, "slot_name", node.slot_name, "String")



	func _t_imodule_lookup(node):
	
		self._check_expr(node, "object_expr", node.object_expr)
		
		if not (Builtins::String.instantiated(node.def_name) | ITree::IInsert.instantiated(node.def_name)):
			self._type_error(node, "def_name", node.def_name, "[String, IInsert]")



	func _t_ilist(node):
	
		if not Builtins::List.conformed_by(node.elements):
			self._type_error(node, "elements", node.elements, "List")
		for i := 0.to(node.elements.len()):
			elem := node.elements[i]
			self._check_expr(node, Strings::format("elem[%d]", i), elem)



	func _t_idict(node):
	
		if not Builtins::List.conformed_by(node.elements):
			self._type_error(node, "elements", node.elements, "List")
		for i := 0.to(node.elements.len()):
			key, val := node.elements[i]
			self._check_expr(node, Strings::format("element[%d] key", i), key)
			self._check_expr(node, Strings::format("element[%d] val", i), val)



	func _t_iset(node):
	
		if not Builtins::List.conformed_by(node.elements):
			self._type_error(node, "elements", node.elements, "List")
		for i := 0.to(node.elements.len()):
			elem := node.elements[i]
			self._check_expr(node, Strings::format("elem[%d]", i), elem)



	func _t_iapplication(node):
	
		self._check_expr(node, "func_expr", node.func_expr)

		if not Builtins::List.conformed_by(node.args):
			self._type_error(node, "args", node.args, "List")
		for arg := node.args.iterate():
			self._check_expr(node, "arg", arg)



	func _t_iget(node):
	
		self._check_expr(node, "get_object", node.get_object)
		self._check_expr(node, "index", node.index)



	func _t_islice(node):
	
		self._check_expr(node, "slice_object", node.slice_object)
		
		if not node.lower_bound is null:
			self._check_expr(node, "lower_bound", node.lower_bound)
			
		if not node.upper_bound is null:
			self._check_expr(node, "upper_bound", node.upper_bound)



	func _t_iexbi(node):

		self._check_expr(node, "object_expr", node.object_expr)

		if not Builtins::String.instantiated(node.field_name):
			self._type_error(node, "field_name", node.slot_name, "String")



	func _t_ireturn(node):
	
		if not node.return_expr is null:
			self._check_expr(node, "return_expr", node.return_expr)



	func _t_iyield(node):
	
		self._check_expr(node, "yield_expr", node.yield_expr)



	func _t_iraise(node):
	
		self._check_expr(node, "raise_expr", node.raise_expr)



	func _t_iassert(node):
	
		self._check_expr(node, "assert_expr", node.assert_expr)



	func _t_ibreak(node):
	
		pass



	func _t_icontinue(node):
	
		pass



	func _t_iconjunction(node):
	
		for expr := node.exprs.iterate():
			self._check_expr(node, "expr", expr)



	func _t_ialternation(node):
	
		for expr := node.exprs.iterate():
			self._check_expr(node, "expr", expr)



	func _t_iassignment(node):
	
		if not ITree::ALL_ASSIGNMENTS.find(node.type):
			raise "XXX"

		if not Builtins::List.conformed_by(node.targets):
			self._type_error(node, "targets", node.exprs, "List")
		for target := node.targets.iterate():
			if ITree::IVar.instantiated(target) | ITree::IGet.instantiated(target) | ITree::ISlot_Lookup.instantiated(target) | ITree::IInsert.instantiated(target):
				self._preorder(target)
			else:
				self._type_error(node, "target", target, "[IVar, IGet, ISlot_Lookup]")
		
		self._check_expr(node, "expr", node.expr)



	func _t_ibinary(node):
	
		if not ITree::ALL_BINARIES.find(node.type):
			raise "XXX"
		
		self._check_expr(node, "lhs", node.lhs)
		self._check_expr(node, "rhs", node.rhs)



	func _t_icomparison(node):
	
		if not ITree::ALL_COMPARISONS.find(node.type):
			raise "XXX"
		
		self._check_expr(node, "lhs", node.lhs)
		self._check_expr(node, "rhs", node.rhs)



	func _t_ipass(node):
	
		pass



	func _t_iinsert(node):
	
		self._check_expr(node, "expr", node.expr)
	
	
	
	func _t_istandard_quasi_quotes(node):
	
		self._check_expr_block(node, "body", node.body)
		
		if not node.extra_src_infos is null:
			self._check_expr(node, "extra_src_infos", node.extra_src_infos)



	func _t_ioriginal_name(node):
	
		if not Builtins::String.instantiated(node.module_id):
			self._type_error(node, "module_id", node.module_id, "String")

		if not Builtins::String.instantiated(node.def_name):
			self._type_error(node, "def_name", node.def_name, "String")
	

	
	func _t_iexpr_block(node):

		if not Builtins::List.conformed_by(node.exprs):
			self._type_error(node, "exprs", node.exprs, "List")
		for elem := node.exprs.iterate():
			self._check_expr(node, "expr", elem)



	func _t_iparam(node):
	
		if not ITree::IVar.instantiated(node.var):
			self._type_error(node, "var", node.var, "IVar")
		
		if not node.default is null:
			self._check_expr(node, "default", node.default)



	func _t_iclause(node):
	
		self._check_expr(node, "condition", node.condition)
		self._check_expr_block(node, "body", node.body)




//
// Typecheck the ITree 'itree' which can be of any valid ITree type.
//

func tc(itree):

	return ITree_TC.new().tc(itree)



//
// Typecheck the ITree 'itree' to ensure it is a valid expression.
//

func tc_expr(itree, msg, src_infos):

	for elem_class := _EXPRS.iterate():
		if elem_class.instantiated(itree):
			break
	exhausted:
		Compiler_Vars::peek_compiler().error(Strings::format("Node %s is of type %s instead of IExpr.", msg, itree.instance_of.name), src_infos)

	return ITree_TC.new().tc(itree)



func type_error(parent_node_name, part, node, should_be, src_infos):

	Compiler_Vars::peek_compiler().error(Strings::format("In %s node, got %s type for %s instead of %s.", parent_node_name, node.instance_of.name, part, should_be), src_infos)
