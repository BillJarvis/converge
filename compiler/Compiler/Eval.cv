// Copyright (c) 2006 King's College London, created by Laurence Tratt
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.


import Platform::Properties
import Builtins, Code_Gen, Core, BC_Lib, BC_Mod, Parser, BC_Pkg, File, Functional, IMod_Gen, ITree, Strings, Targets::Available, Tokenizer, VM




class Eval_Compiler:

	func init(self, str, vars, includes):
	
		self._str := str
		self.vars := vars
		
		self.includes := includes
		self.mod_id := Strings::format(Core::UNIQUE_EVAL_NAME_TEMPLATE, Core::fresh_name())
		self.src_path := self.mod_id
		self.internal_target := self.target := Available::TARGETS[Strings::format("%dbit", Properties::word_bits)].new()

		self._cached_mods := Dict{}
		for lib_path := Core::get_std_libraries().iter():
			bc_lib := BC_Lib::BC_Lib.new(self.target)
			lib_file := File::open(lib_path, "r")
			lib_bc := lib_file.read()
			lib_file.close()
			for bc_mod := bc_lib.deserialize(lib_bc).iter():
				self._cached_mods[bc_mod.get_mod_id()] := [bc_mod.get_src_path(), bc_mod]



	func eval(self):
		
		self.tokenizer := Tokenizer::Tokenizer.new()
		parse_tree := Parser::parse_expr_body(self._str)
		self.newlines := self.tokenizer.newlines
		
		body := []
		
		compiler_var_name := Core::fresh_name()
		compiler_var := ITree::IVar.new(compiler_var_name, [])
		peek_compiler := ITree::IModule_Lookup.new([ITree::IMod_Id_Import.new(Core.mod_id, Core.src_path, []), ITree::IVar.new("peek_compiler", [])], [])
		body.append(ITree::IAssignment.new(ITree::STD_ASSIGN, [compiler_var], ITree::IApplication.new(peek_compiler, [], []), []))
		
		vars_val := ITree::ISlot_Lookup.new(compiler_var, "vars", [])
		for var_name, _ := self.vars.iter():
			var_val := ITree::IApplication.new(ITree::ISlot_Lookup.new(vars_val, "get", []), [ITree::IString.new(var_name, [])], [])
			body.append(ITree::IAssignment.new(ITree::STD_ASSIGN, [ITree::IVar.new(var_name, [])], var_val, []))

		expr_body := IMod_Gen::IMod_Gen.new().gen_expr_body(parse_tree)
		if expr_body.exprs.len() == 0:
			fail
		elif expr_body.exprs.len() > 1:
			raise "XXX"
			
		expr := expr_body.exprs[0]

		dict_vals := []
		for var_name, var_val := self.vars.iter():
			dict_vals.append([ITree::IString.new(var_name, []), ITree::IVar.new(var_name, [])])
		rtn_dict := ITree::IDict.new(dict_vals, [])

		vars_assign := []
		vars_assign_names := Set{}
		for var_name, _ := self.vars.iter():
			vars_assign_names.add(var_name)
		vars_assign_names.extend(expr.bound_vars)
		for var_name := vars_assign_names.iter():
			var_val := ITree::IApplication.new(ITree::ISlot_Lookup.new(vars_val, "set", []), [ITree::IString.new(var_name, []), ITree::IVar.new(var_name, [])], [])
			vars_assign.append(var_val)

		rtn_ivar := ITree::IVar.new(Core::fresh_name(), [])
		icond := ITree::IAssignment.new(ITree::STD_ASSIGN, [rtn_ivar], expr, [])
		iclause_body := ITree::IExpr_Block.new([vars_assign, ITree::IReturn.new(rtn_ivar, [])].flattened(), [])
		iclause := ITree::IClause.new(icond, iclause_body, [])
		ielse_body := ITree::IExpr_Block.new([vars_assign, ITree::IFail.new([])].flattened(), [])
		iif := ITree::IIf.new([iclause], ielse_body, [])
		body.append(iif)

		eval_name := Core::fresh_name()		
		dummy_func := ITree::IFunc_Defn.new(0, ITree::IVar.new(eval_name, []), [], null, [], [], ITree::IExpr_Block.new(body, []), [])
		dummy_defns := [ITree::IAssignment.new(ITree::STD_ASSIGN, [ITree::IVar.new(eval_name, [])], dummy_func, [])]
		dummy_imodule := ITree::IModule.new(eval_name, dummy_defns, [])
		
		bc_mod := _Eval_Code_Gen.new().generate(dummy_imodule, self.target)
		mod := Builtins::Module.new(bc_mod.serialize())
		
		bc_mod_stack := [bc_mod]
		mod_stack := [mod]
		mod_ids := Set{}
		i := 0
		while i < mod_stack.len():
			bc_mod := bc_mod_stack[i]
			for imp_mod_id, imp_src_path := bc_mod.get_imports().iter():
				if not VM::find_module(imp_mod_id) & not mod_ids.find(imp_mod_id):
					bc_mod := self.get_bc_mod(imp_mod_id, imp_src_path, [])
					bc_mod_stack.append(bc_mod)
					mod_stack.append(Builtins::Module.new(bc_mod.serialize()))
					mod_ids.add(imp_mod_id)

			i += 1
		
		VM::add_modules(mod_stack)
		main_mod := VM::import_module(mod_stack[0])
		for mod := mod_stack.iter(1):
			VM::import_module(mod)
		
		return main_mod.get_defn(eval_name)()



	func find_import_location(self, import_name_list):

		func match_path(i, dir):
		
			cnd_path := File::join_names(dir, import_name_list[i])

			if File::exists(cnd_path) & File::is_dir(cnd_path):
				if i + 1 == import_name_list.len():
					return [cnd_path, i]
				else:
					return match_path(i + 1, cnd_path)

			cnd_file_path := File::join_ext(cnd_path, Core::SRC_EXT)
			if File::exists(cnd_file_path) & File::is_file(cnd_file_path):
				return [cnd_file_path, i]
			
			fail
			
	
		for include_dir := self.includes.iter():
			if matched_path, extra_pos := match_path(0, include_dir):
				src_path := File::canon_path(matched_path)
				if cvb_path := Core::get_cache_path(src_path) & File::exists(cvb_path):
					f := File::open(cvb_path, "r")
					bc := f.read()
					if BC_Mod::is_bc_mod(bc):
						bc_mod := BC_Mod::BC_Mod.new(self.internal_target)
					else:
						bc_mod := BC_Pkg::BC_Pkg.new(self.internal_target)
					bc_mod.deserialize_str(bc)
					f.close()
					mod_id := bc_mod.get_mod_id()
				else:
					mod_id := Core::mk_mod_id(src_path)
				import_extras := import_name_list[extra_pos + 1 : ]
				break
		exhausted:
			// If the first part of the import references a builtin, then looking up that module ID
			// will succeed.
			if VM::find_module(import_name_list[0]):
				mod_id := src_path := import_name_list[0]
				import_extras := import_name_list[1 : ]
			else:
				fail
		
		return [mod_id, src_path, import_extras]



	func get_bc_mod(self, mod_id, src_path, src_infos):

		if cache_src_path, cache_bc_mod := self._cached_mods.find(mod_id):
			return cache_bc_mod

		cvb_path := Core::get_cache_path(src_path)
		if File::exists(cvb_path):
			cvb_file := File::open(cvb_path, "r")
			bc := cvb_file.read()
			cvb_file.close()
			if BC_Mod::is_bc_mod(bc):
				mod := BC_Mod::BC_Mod.new(self.target)
				mod.deserialize_str(bc)
				return mod
		
		self.error(Strings::format("Unable to import '%s'.", src_path), src_infos)




class _Eval_Code_Gen(Code_Gen::Code_Gen):

	func _prc_mod_lookup(self, mod_lookup):

		assert _Eval_Compiler.instantiated(self._compiler)

		if not (val := self._compiler.vars.find(mod_lookup.names[0].name)):
			// Since this doesn't even refer to a valid variable, a "variable not found" error will
			// be raised elsewhere, so we don't bother dealing with it here.
			return

		if not Builtins::Module.instantiated(val):
			self._compiler.warning("Unable to determine module referenced in lookup (use a plain variable lookup instead)", mod_lookup.names[0].src_infos)




func eval(str, vars := Dict{}, includes := []):

	compiler := Eval_Compiler.new(str, vars, includes)
	Core::push_compiler(compiler)
	if not (result := compiler.eval()):
		Core::pop_compiler()
		fail
	else:
		Core::pop_compiler()
		return result
