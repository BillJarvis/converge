// Copyright (c) 2003-2006 King's College London, created by Laurence Tratt
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.


import Exceptions, Strings, Sys




MANDATORY := 0
OPTIONAL := 1
NONE := 2

TYPE_ANY := 0

FREQUENCY_ONE := 0
FREQUENCY_ZERO_OR_ONE := 1
FREQUENCY_ZERO_OR_MORE := 2



class Option_Spec:

	func init(name, short_option, optionality := NONE, type := TYPE_ANY, frequency := FREQUENCY_ZERO_OR_ONE):
	
		self.name := name
		self.short_option := short_option
		self.optionality := optionality
		self.type := type
		self.frequency := frequency




class Options:

	func init(useage_callback):
	
		self._useage_callback := useage_callback
		self._option_specs := []



	func add(option_spec):
	
		if self._option_specs.find(option_spec.name):
			raise Exceptions::User_Exception.new(Strings::format("Option '%s' has already been specified.", option_spec.name))
			
		self._option_specs.append(option_spec)



	func parse():
	
		options := Dict{}
		
		i := 0
		while i < Sys::argv.len():
			arg := Sys::argv[i]
			if arg == "--":
				i += 1
				break
			elif arg.len() > 0 & arg[0] == "-":
				option_spec := null
				
				if arg.len() == 2:
					for option_spec := self._option_specs.iterate():
						if option_spec.short_option == arg[1 : ]:
							break
				elif arg.len() > 2 & arg[0 : 2] == "--":
					for option_spec := self._option_specs.iterate():
						if option_spec.name == arg[2 : ]:
							break

				if option_spec is null:
					self._useage_callback(Strings::format("Unknown option '%s'.", arg))
				
				if option_spec.optionality == NONE:
					val := null
					i += 1
				elif option_spec.optionality == OPTIONAL:
					if i + 1 < Sys::argv.len() & (Sys::argv[i + 1].len() == 0 | Sys::argv[i + 1][0] != "-"):
						val := Sys::argv[i + 1]
						i += 2
					else:
						val := null
						i += 1
				else:
					// By definition: option_spec.optionality == MANDATORY
					
					if i + 1 == Sys::argv.len():
						self._useage_callback(Strings::format("'-%s' requires a value.", option_spec.short_option))
					val := Sys::argv[i + 1]
					i += 2

				if option_spec.frequency == FREQUENCY_ONE | option_spec.frequency == FREQUENCY_ZERO_OR_ONE:
					if options.find(option_spec.name):
						self._useage_callback(Strings::format("'%s' option may be specified a maximum of once.", option_spec.short_option))
					options[option_spec.name] := val
				elif option_spec.frequency == FREQUENCY_ZERO_OR_MORE:
					if not options.find(option_spec.name):
						options[option_spec.name] := []
					options[option_spec.name].append(val)
			else:
				break

		for option_spec := self._option_specs.iterate():
			if option_spec.optionality == MANDATORY & not options.find(option_spec.name):
				self._useage_callback(Strings::format("'%s' option must be specified.", option_spec.short_option))

		return [options, Sys::argv[i : ]]
