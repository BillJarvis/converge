// Copyright (c) 2003-2006 King's College London, created by Laurence Tratt
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.


import File, Functional, Strings
import CEI, ITree




_INDENT_STRING := "\t"




class ITree_Format:

	func format(itree):
	
		self._indent_level := 0
		
		return self._preorder(itree)



	func _preorder(node):
	
		return self.get_slot("_t_" + node.instance_of.name.to_lower_case())(node)



	func _t_ifunc_def(node):

		params := Strings::join(Functional::map(self._preorder, node.params), ", ")
		if not node.var_arg is null:
			var_arg := self._preorder(node.var_arg)
		else:
			var_arg := ""
		
		if node.nonlocals.len() != 0:
			raise "XXX"

		if node.renames.len() != 0:
			raise "XXX"
		
		self._indent_level += 1
		body := self._preorder(node.body)
		self._indent_level -= 1

		return Strings::format("""func %s(%s%s):

%s%s""", node.func_name, params, var_arg, _INDENT_STRING * (self._indent_level + 1), body)



	func _t_iif(node):
	
		pp := []
		for i := 0.to(node.clauses.len()):
			if i == 0:
				pp.append("if ")
			else:
				pp.append(Strings::format("\n%selif ", _INDENT_STRING * self._indent_level))
			self._indent_level += 1
			pp.append(Strings::format("%s:", self._preorder(node.clauses[i].condition)))
			pp.append("\n" + (_INDENT_STRING * self._indent_level))
			pp.append(self._preorder(node.clauses[i].body))
			self._indent_level -= 1
		if not node.else_body is null:
			pp.append(Strings::format("\n%selse:\n%s", _INDENT_STRING * self._indent_level, _INDENT_STRING * (self._indent_level + 1)))
			self._indent_level += 1
			pp.append(self._preorder(node.else_body))
			self._indent_level -= 1
		
		return Strings::join(pp, "")
	


	func _t_iimport(node):
	
		return Strings::format("import %s", File::split_ext(File::split_leaf(node.module_path)[1])[0])



	func _t_ivar(node):
	
		return node.var_name



	func _t_iint(node):
	
		return Strings::format("%d", node.val)



	func _t_ilist(node):

		return Strings::format("[%s]", Strings::join(Functional::map(self._preorder, node.elements), ", "))



	func _t_istring(node):
	
		return Strings::format("\"%s\"", node.string)



	func _t_islot_lookup(node):

		return Strings::format("%s.%s", self._preorder(node.object_expr), node.slot_name)



	func _t_imodule_lookup(node):

		return Strings::format("%s::%s", self._preorder(node.object_expr), node.def_name)



	func _t_ilist(node):
	
		return Strings::format("[%s]", Strings::join(Functional::map(self._preorder, node.elements), ", "))



	func _t_iapplication(node):
	
		return Strings::format("%s(%s)", self._preorder(node.func_expr), Strings::join(Functional::map(self._preorder, node.args), ", "))



	func _t_iget(node):

		return Strings::format("%s[%s]", self._preorder(node.get_object), self._preorder(node.index))



	func _t_ireturn(node):
	
		if node.return_expr is null:
			return "return"
		else:
			return Strings::format("return %s", self._preorder(node.return_expr))



	func _t_iyield(node):

		return Strings::format("yield %s", self._preorder(node.yield_expr))



	func _t_iraise(node):

		return Strings::format("raise %s", self._preorder(node.raise_expr))



	func _t_iassert(node):

		return Strings::format("assert %s", self._preorder(node.assert_expr))



	func _t_ibreak(node):

		return "break"



	func _t_icontinue(node):

		return "continue"



	func _t_iconjunction(node):
	
		return Strings::join(Functional::map(self._preorder, node.exprs), " | ")



	func _t_inot(node):

		return Strings::format("not %s", self._preorder(node.expr))



	func _t_iassignment(node):
	
		if node.type == ITree::STD_ASSIGN:
			op := ":="
		elif node.type == ITree::ADD_ASSIGN:
			op := "+="
		elif node.type == ITree::SUB_ASSIGN:
			op := "-="
		elif node.type == ITree::MUL_ASSIGN:
			op := "*="
		elif node.type == ITree::DIV_ASSIGN:
			op := "/="
		
		return Strings::format("%s %s %s", Strings::join(Functional::map(self._preorder, node.targets), ", "), op, self._preorder(node.expr))



	func _t_icomparison(node):
	
		if node.type == ITree::IS_COMPARISON:
			op := "is"
		elif node.type == ITree::EQ_COMPARISON:
			op := "=="
		elif node.type == ITree::NEQ_COMPARISON:
			op := "!="
		elif node.type == ITree::LEQ_COMPARISON:
			op := "<="
		elif node.type == ITree::GEQ_COMPARISON:
			op := ">="
		elif node.type == ITree::LE_COMPARISON:
			op := "<"
		elif node.type == ITree::GE_COMPARISON:
			op := ">"
	
		return Strings::format("%s %s %s", self._preorder(node.lhs), op, self._preorder(node.rhs))



	func _t_ibinary(node):

		if node.type == ITree::BINARY_ADD:
			op := "+"
		elif node.type == ITree::BINARY_SUB:
			op := "-"
		elif node.type == ITree::BINARY_MUL:
			op := "*"
		elif node.type == ITree::BINARY_DIV:
			op := "/"
		elif node.type == ITree::BINARY_MOD:
			op := "%"
	
		return Strings::format("%s %s %s", self._preorder(node.lhs), op, self._preorder(node.rhs))



	func _t_ioriginal_name(node):
	
		if node.module_id == CEI::compiler().src_path:
			return node.def_name // XXX
		else:
			raise "XXX"



	func _t_iexpr_block(node):

		pp := []
		for expr := node.exprs.iterate():
			pp.append(self._preorder(expr))
		
		return Strings::join(pp, "\n" + (_INDENT_STRING * self._indent_level))

		
		
	func _t_iparam(node):
	
		if not node.default is null:
			return Strings::format("%s := %s", self._preorder(node.var), self._preorder(node.default))
		else:
			return self._preorder(node.var)




func format(itree):

	return ITree_Format.new().format(itree)
