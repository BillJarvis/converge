// Copyright (c) 2007 Laurence Tratt
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.


import Array, File, Strings
import Bytecode_Gen, Core, CV_Exec, CV_Pkg, ITree




class _Link_Exec:

	func link_exec(self, mods, linker, target):

		self._mods := mods
		self._linker := linker
		self._target := target
		
		self._mods_map := Dict{}
		for mod := mods.iter():
			self._mods_map[mod.get_mod_id()] := mod
		
		self._done_mods := [] // List of CV_Module instances
		self._done_mod_ids := Set{} // Set of module IDs
		self._pkgs := Dict{} // Map package mod ids to sets of definition names to be included

		self._scan()
		self._mk_pkgs()

		for mod := self._done_mods.iter():
			for import_mod_id, import_src_path := mod.get_imports().iter():
				if not Core::BUILTIN_MODULES.find(import_mod_id) & not self._done_mod_ids.find(import_mod_id):
					linker.error(Strings::format("Module '%s' referenced in '%s' not found in input files.", import_mod_id, mod.get_mod_id()))
				
		ser_mods := Array::Array.new(target.ARRAY_TYPE)
		ser_mods_offsets := []
		for mod := self._done_mods.iter():
			ser_mods_offsets.append(ser_mods.len_bytes())
			ser_mods.extend_from_string(mod.serialize())

		linked_bytecode := Array::Array.new(target.ARRAY_TYPE)
		linked_bytecode.extend_from_string(CV_Exec::EXEC_INIT_STRING)
		linked_bytecode.append(0)  // Version
		linked_bytecode.append(-1) // Number of modules
		linked_bytecode[target.LIBRARY_BYTECODE_NUM_MODULES] := ser_mods_offsets.len()

		preamble_length := (linked_bytecode.len() + ser_mods_offsets.len()) * target.WORDSIZE
		for mod_offset := ser_mods_offsets.iter():
			linked_bytecode.append(preamble_length + mod_offset)

		linked_bytecode.extend(ser_mods)

		sh_header := "#! /usr/bin/env converge\n"
		ser := sh_header + "\n" * (target.align(sh_header.len()) - sh_header.len()) + linked_bytecode.serialize()

		return ser



	func _scan(self):

		// Using the first module on the command line as a "seed", we now scan through and try and
		// pluck out all the imports that it refers to (directly and indirectly through other
		// modules).

		todo := [self._mods[0].get_mod_id()] // List of module IDs
		while todo.len() > 0:
			mod_id := todo[0]
			todo.del(0)
			mod := self._mods_map[mod_id]
			
			if CV_Pkg::CV_Pkg.instantiated(mod):
				// Packages at this point are CV_Pkg instances, so we don't scan through them.
				if not self._pkgs.find(mod_id):
					self._pkgs[mod_id] := Set{}
				continue

			self._done_mod_ids.add(mod_id)
			self._done_mods.append(mod)

			for imp_mod_id, imp_src_path := mod.get_imports().iter():
				if not Core::BUILTIN_MODULES.find(imp_mod_id):
					if not (self._done_mod_ids.find(imp_mod_id) | todo.find(imp_mod_id)):
						todo.append(imp_mod_id)

			for mod_num, defn_names, src_infos := mod.get_mod_lookups().iter():	
				lookedup_mod_id := mod.get_imports()[mod_num][0]
				j := 1
				while j < defn_names.len():
					defn_name := defn_names[j]
					if lookedup_mod := self._mods_map.find(lookedup_mod_id):
						if CV_Pkg::CV_Pkg.instantiated(lookedup_mod):
							if not entry_mod_id, entry_src_path := lookedup_mod.get_entries().find(defn_name):
								// The requested definition definitely doesn't exist in the looked-up
								// module, so raise an error.
								self._linker.error(Strings::format("Can't find definition '%s' in '%s'.", defn_name, Strings::join(defn_names[ : j], "::")), _tn_src_infos(src_infos, self._mods_map[mod_id]))
							
							self._add_to_pkg(lookedup_mod_id, defn_name)
							
							lookedup_mod_id := entry_mod_id
						else:
							if not (defn_num := lookedup_mod.get_top_level_vars_map().find(defn_name)):
								// The requested definition definitely doesn't exist in the looked-up
								// module, so raise an error.
								self._linker.error(Strings::format("Can't find definition '%s' in '%s'.", defn_name, Strings::join(defn_names[ : j], "::")), _tn_src_infos(src_infos, self._mods_map[mod_id]))

							if lookedup_mod_num := lookedup_mod.get_import_defns().find(defn_num):
								lookedup_mod_id := lookedup_mod.get_imports()[lookedup_mod_num][0]
							else:
								if j + 1 < defn_names.len():
									// We can't trace the next definition in the current known
									// module; it might exist at run-time, it might not. Print
									// a warning, and give up further processing of this lookup,
									// but do not halt the linking process.
									msg := Strings::format("Unable to trace definition '%s' in '%s'.", defn_names[j + 1], Strings::join(defn_names[ : j + 1], "::"))
									self._linker.warning(msg, _tn_src_infos(src_infos, self._mods_map[mod_id]))
									break
						
						if not (self._done_mod_ids.find(lookedup_mod_id) | todo.find(lookedup_mod_id)):
							todo.append(lookedup_mod_id)
					elif Core::BUILTIN_MODULES.find(lookedup_mod_id):
						// XXX we don't trace builtins yet
						break
					else:
						self._linker.error(Strings::format("Module '%s' referenced in '%s' not found.", lookedup_mod_id, mod_id), _tn_src_infos(src_infos, self._mods_map[mod_id]))

					j += 1



	func _add_to_pkg(self, pkg_id, defn_name):
	
		if not pkg := self._pkgs.find(pkg_id):
			self._pkgs[pkg_id] := pkg := Set{}
		
		pkg.add(defn_name)



	func _mk_pkgs(self):

		for pkg_id, defn_names := self._pkgs.iter():
			// XXX: It's not entirely clear what reasonable src infos for the ITree module are.

			cv_pkg := self._mods_map[pkg_id]
			entries := cv_pkg.get_entries()

			idefns := []
			for defn_name := defn_names.iter():
				entry_mod_id, entry_src_path := entries[defn_name]
				mod_import := ITree::IMod_Id_Import.new(entry_mod_id, entry_src_path, [])
				var_name := ITree::IVar.new(defn_name, [])
				asgn := ITree::IAssignment.new(ITree::STD_ASSIGN, [var_name], mod_import, [])
				idefns.append(asgn)
			imod := ITree::IModule.new(cv_pkg.get_name(), idefns, [])

			// We now setup a minimal compiler and compile the ITree into a CV_Module.

			self.mod_id := pkg_id
			self.src_path := cv_pkg.get_src_path()
			self.newlines := []
			Core::push_compiler(self)
			pkg_as_mod := Bytecode_Gen::Bytecode_Gen.new().generate(imod, self._target)
			Core::pop_compiler()
			
			self._done_mods.append(pkg_as_mod)
			self._done_mod_ids.add(pkg_id)




func link_exec(mods, linker, target):

	return _Link_Exec.new().link_exec(mods, linker, target)



//
// Translates lists of bytecode src infos of the form [<import num>, <offset>] to proper src
// infos of the form [<module id>, <offset>].
//

func _tn_src_infos(src_infos, mod):

	new_src_infos := []
	for mod_num, offset := src_infos.iter():
		if mod_num == -1:
			new_src_infos.append([mod.get_mod_id(), offset])
		else:
			new_src_infos.append([mod.get_imports()[mod_num][0], offset])

	return new_src_infos
