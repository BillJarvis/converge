// Copyright (c) 2003-2006 King's College London, created by Laurence Tratt
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.


import Builtins, Exceptions, Strings, Thread
import CPK::Earley::Grammar
import Compiler_Vars, convergec, CV_Parser, Eval, ITree, ITree_Format, ITree_TC, Tokenizer




func compiler():

	return Compiler_Vars::peek_compiler()



func error(msg, src_infos := null):

	Compiler_Vars::peek_compiler().error(msg, src_infos)



func warning(msg, src_infos := null):

	Compiler_Vars::peek_compiler().warning(msg, src_infos)



func eval(str, vars := Dict{}, includes := []):

	return Eval::eval(str, vars, includes)



func fresh_name(name := null):

	return Compiler_Vars::fresh_name(name)



func itree_format(itree):

	return ITree_Format::format(itree)



func lift(obj, src_infos := null):

	if src_infos is null:
		src_infos := Thread::get_continuation_src_infos(2)
	else:
		src_infos += Thread::get_continuation_src_infos(2)

	if obj is null:
		return ITree::IVar.new("null", src_infos)
	elif Builtins::String.conformed_by(obj):
		return ITree::IString.new(obj, src_infos)
	elif Builtins::Int.conformed_by(obj):
		return ITree::IInt.new(obj, src_infos)
	elif Builtins::List.conformed_by(obj):
		elems := []
		for e := obj.iterate():
			elems.append(lift(e, src_infos))
		return ITree::IList.new(elems, src_infos)
	elif Builtins::Set.conformed_by(obj):
		elems := []
		for e := obj.iterate():
			elems.append(lift(e, src_infos))
		return ITree::ISet.new(elems, src_infos)
	elif Builtins::Dict.conformed_by(obj):
		elems := []
		for key, val := obj.iterate():
			elems.append([lift(key, src_infos), lift(val, src_infos)])
		return ITree::IDict.new(elems, src_infos)
	else:
		raise Exceptions::Exception.new(Strings::format("Don't know how to lift instance of '%s': '%s'.", obj.instance_of.name, obj.to_str()))



func dsl_parse(dsl_block, src_infos, extra_keywords, extra_symbols, grammar, start_rule):

	tokenizer := Tokenizer::Tokenizer.new()
	tokenizer.tokenize(dsl_block, src_infos, extra_keywords, extra_symbols)
	
	tokens_map := Tokenizer::tokens_map(extra_symbols, extra_keywords)
	grammar, rule_names := Grammar::compile(grammar, start_rule, tokens_map)
	parser := CV_Parser::CV_Parser.new()
	
	return parser.parse(grammar, rule_names, tokens_map, tokenizer.tokens)



////
//// This function creates all the factory functions for ITree elements.
////
//
//func _ibuilder():
//
//	builders := []
//	for def_name := ITree.def_names():
//		if def_name[0] != "I" | not Builtins::Class.instantiated(def := ITree.get_def(def_name)):
//			continue
//		num_params := ITree::IInt.new(ITree.get_def(def_name).get_field("init").num_params, __SRC_INFO__)
//		builders.append([|
//			func ${def_name.to_lower_case()}(*args):
//			
//				// Add src info from the calling function.
//
//				if args.len() == ${num_params} - 1:
//					args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
//				else:
//					args := args + [Thread::get_continuation_src_infos(2)]
//
//				// Create the element and immediately type check it.
//
//				elem := ITree::${ITree::IVar.new(def_name, __SRC_INFO__)}.new.apply(args)
//				ITree_TC::tc(elem)
//				
//				return elem
//		|])
//	
//	return builders
//
//
//$<_ibuilder()>


 
func imodule(*args):

	elem := ITree::IModule

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func iclass_def(*args):

	elem := ITree::IClass_Def

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func ifunc_def(*args):

	elem := ITree::IFunc_Def

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func iif(*args):

	elem := ITree::IIf

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func indif(*args):

	elem := ITree::INDIf

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func ivar(*args):

	elem := ITree::IVar

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func iimport(*args):

	elem := ITree::IImport

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func iwhile(*args):

	elem := ITree::IWhile

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func ifor(*args):

	elem := ITree::IFor

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func iint(*args):

	elem := ITree::IInt

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func istring(*args):

	elem := ITree::IString

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func islot_lookup(*args):

	elem := ITree::ISlot_Lookup

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func imodule_lookup(*args):

	elem := ITree::IModule_Lookup

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func ilist(*args):

	elem := ITree::IList

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func idict(*args):

	elem := ITree::IDict

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func iset(*args):

	elem := ITree::ISet

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func iapplication(*args):

	elem := ITree::IApplication

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func iget(*args):

	elem := ITree::IGet

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func islice(*args):

	elem := ITree::ISlice

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func iexbi(*args):

	elem := ITree::IEXBI

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func ireturn(*args):

	elem := ITree::IReturn

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func iyield(*args):

	elem := ITree::IYield

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func iraise(*args):

	elem := ITree::IRaise

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func iassert(*args):

	elem := ITree::IAssert

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func ibreak(*args):

	elem := ITree::IBreak

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func icontinue(*args):

	elem := ITree::IContinue

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func iconjunction(*args):

	elem := ITree::IConjunction

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func ialternation(*args):

	elem := ITree::IAlternation

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func iassignment(*args):

	elem := ITree::IAssignment

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func inot(*args):

	elem := ITree::INot

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func ibinary(*args):

	elem := ITree::IBinary

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func icomparison(*args):

	elem := ITree::IComparison

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func ipass(*args):

	elem := ITree::IPass

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func iinsert(*args):

	elem := ITree::IInsert

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func istandard_quasi_quotes(*args):

	elem := ITree::IStandard_Quasi_Quotes

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func ioriginal_name(*args):

	elem := ITree::IOriginal_Name

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func iexpr_block(*args):

	elem := ITree::IExpr_Block

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func iparam(*args):

	elem := ITree::IParam

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



func iclause(*args):

	elem := ITree::IClause

	if args.len() == elem.get_field("init").num_params - 1:
		args := args[ : -1] + [(args[-1] + Thread::get_continuation_src_infos(2))]
	else:
		args := args + [Thread::get_continuation_src_infos(2)]

	elem := elem.new.apply(args)
	ITree_TC::tc(elem)

	return elem



