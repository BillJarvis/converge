// Copyright (c) 2003-2006 King's College London, created by Laurence Tratt
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.


import Array, File, Maths, Parse_Options, Platform::Properties, Strings, Sys
import Bytecode_Gen, Compiler_Vars, CV_Exec, CV_Module, CV_Library, Mk_Packages, Targets::Available, VM




func _usage(msg):
	
	Sys::stderr.writeln(Strings::format("Error: %s", msg))
	Sys::stderr.writeln("Usage: convergel [-l] -o <output> <input> [... <input>]")
	Sys::exit(1)



func _error(msg):
	
	Sys::stderr.writeln(Strings::format("Error: %s", msg))
	Sys::exit(1)
		



class Linker:

	func init(self):
	
		self.includes := []
	
		options := Parse_Options::Options.new(_usage)
		options.add(Parse_Options::Option_Spec.new("output", "o", Parse_Options::MANDATORY, Parse_Options::TYPE_ANY, Parse_Options::FREQUENCY_ONE))
		options.add(Parse_Options::Option_Spec.new("mk_shell_script", "s", Parse_Options::NONE, null, Parse_Options::FREQUENCY_ZERO_OR_ONE))
		options.add(Parse_Options::Option_Spec.new("target", "T", Parse_Options::MANDATORY, Parse_Options::TYPE_ANY, Parse_Options::FREQUENCY_ZERO_OR_ONE))
		
		target_name := Strings::format("%dbit", Properties::word_bits)
		mk_shell_script := 0
		parsed_args, extra_args := options.parse()
		for option_name, option_val := parsed_args.iterate():
			if option_name == "output":
				output_path := option_val
			elif option_name == "target":
				target_name := option_val
			elif option_name == "mk_shell_script":
				mk_shell_script := 1
			else:
				raise "XXX"
		
		if extra_args.len() == 0:
			_usage("Not enough arguments.")

		target := _target_name_to_target(target_name)

		modules := Dict{}
		first_module_id := null
		for input_path := extra_args.iterate():
			input_path := File::canon_path(input_path)
			input_file := File::open(input_path, "r")
			input_file_data := input_file.read()
			assert(CV_Library::LIBRARY_INIT_STRING.len() == CV_Module::MODULE_INIT_STRING.len())
			file_type := input_file_data[ : CV_Library::LIBRARY_INIT_STRING.len()]
			
			if file_type == CV_Library::LIBRARY_INIT_STRING:
				if first_module_id is null:
					raise "XXX"
				library := CV_Library::CV_Library.new(target)
				for module_str, module := library.deserialize(input_file_data).iterate():
					modules[module.get_identifier()] := [module_str, module]
			elif file_type == CV_Module::MODULE_INIT_STRING:
				module := CV_Module::CV_Module.new(target)
				module.deserialize_str(input_file_data)
				modules[module.get_identifier()] := [input_file_data, module]
				if first_module_id is null:
					first_module_id := module.get_identifier()
			else:
				_error(Strings::format("File '%s' is not of a known type.", input_path))

		linked_bytecode := Array::Array.new(target.ARRAY_TYPE)
		linked_bytecode.extend_from_string(CV_Exec::EXEC_INIT_STRING)
		linked_bytecode.append(0)  // Version
		linked_bytecode.append(-1) // Number of modules
		
		// Using the first module on the command line as a "seed", we now go through and try and
		// pluck out all the imports that it refers to (directly and indirectly through other
		// modules).
		//
		// This happens in two phases. First we try and find "normal" modules. Then we construct
		// any packages required. Then we check to see if we're missing any files that would need
		// to be imported.
		
		modules_stack := [first_module_id]
		assert(modules.find(modules_stack[0]))
		modules_offsets := []
		linked_modules := []
		modules_bytecode := Array::Array.new(target.ARRAY_TYPE)
		i := 0
		while i < modules_stack.len():
			module_id := modules_stack[i]
			modules_offsets.append(modules_bytecode.len_bytes())
			module_str, module := modules[module_id]
			modules_bytecode.extend_from_string(module_str)
			linked_modules.append(module)
			for import_module_id := module.get_imports().iterate():
				if not Compiler_Vars::BUILTIN_MODULES.find(import_module_id):
					if not modules_stack.find(import_module_id):
						if modules.find(import_module_id):
							modules_stack.append(import_module_id)
			i += 1

		pkgs := Mk_Packages::mk_packages(linked_modules, target)
		for pkg := pkgs.iterate():
			linked_modules.append(pkg)
			modules_offsets.append(modules_bytecode.len_bytes())
			modules_bytecode.extend_from_string(pkg.serialize())

		module_ids := Set{}
		for module := linked_modules.iterate():
			module_ids.add(module.get_identifier())
		
		for module := linked_modules.iterate():
			for import_ := module.get_imports().iterate():
				if not Compiler_Vars::BUILTIN_MODULES.find(import_) & not module_ids.find(import_):
					_error(Strings::format("Module '%s' referenced in '%s' not found in input files.", import_, module_id))

		linked_bytecode[target.LIBRARY_BYTECODE_NUM_MODULES] := modules_offsets.len()
		
		preamble_length := (linked_bytecode.len() + modules_offsets.len()) * target.WORDSIZE
		for module_offset := modules_offsets.iterate():
			linked_bytecode.append(preamble_length + module_offset)

		linked_bytecode.extend(modules_bytecode)

		output_file := File::File.new(output_path, "w")
		if mk_shell_script == 1:
			sh_header := "#! /usr/bin/env converge\n"
			output_file.write(sh_header + "\n" * (target.align(sh_header.len()) - sh_header.len()))
		output_file.write(linked_bytecode.serialize())






class Library_Linker:

	func init(self):
	
		self.includes := []
	
		options := Parse_Options::Options.new(_usage)
		options.add(Parse_Options::Option_Spec.new("library_mode", "l", Parse_Options::NONE, Parse_Options::TYPE_ANY, Parse_Options::FREQUENCY_ONE))
		options.add(Parse_Options::Option_Spec.new("output", "o", Parse_Options::MANDATORY, Parse_Options::TYPE_ANY, Parse_Options::FREQUENCY_ONE))
		options.add(Parse_Options::Option_Spec.new("target", "T", Parse_Options::MANDATORY, Parse_Options::TYPE_ANY, Parse_Options::FREQUENCY_ZERO_OR_ONE))
		
		target_name := Strings::format("%dbit", Properties::word_bits)
		parsed_args, extra_args := options.parse()
		for option_name, option_val := parsed_args.iterate():
			if option_name == "library_mode":
				pass
			elif option_name == "output":
				output_path := option_val
			elif option_name == "target":
				target_name := option_val
			else:
				raise "XXX"
		
		if extra_args.len() == 0:
			_usage("Not enough arguments.")

		target := _target_name_to_target(target_name)

		modules := []
		for input_path := extra_args.iterate():
			input_path := File::canon_path(input_path)
			input_file := File::open(input_path, "r")
			input_file_data := input_file.read()
			assert(CV_Library::LIBRARY_INIT_STRING.len() == CV_Module::MODULE_INIT_STRING.len())
			file_type := input_file_data[ : CV_Library::LIBRARY_INIT_STRING.len()]
			
			if file_type == CV_Library::LIBRARY_INIT_STRING:
				library := CV_Library::CV_Library.new(target)
				for module_str, module := library.deserialize(input_file_data).iterate():
					modules.append(module_str)
			elif file_type == CV_Module::MODULE_INIT_STRING:
				modules.append(input_file_data)

		// In one sense, the following should belong in CV_Library::CV_Library.serialize. But by
		// doing it here we can forego the pointless string -> array -> string conversion.

		library := Array::Array.new(target.ARRAY_TYPE)
		library.extend_from_string(CV_Library::LIBRARY_INIT_STRING)
		library.append(CV_Library::LIBRARY_VERSION)

		library.append(modules.len())
		
		offsets := Array::Array.new(target.ARRAY_TYPE)
		serialized_modules := Array::Array.new(target.ARRAY_TYPE)
		for module := modules.iterate():
			offsets.append((library.len() + modules.len() + serialized_modules.len()) * target.WORDSIZE)
			serialized_modules.extend_from_string(module)
		
		library.extend(offsets)
		library.extend(serialized_modules)		
		
		output_file := File::File.new(output_path, "w")
		output_file.write(library.serialize())




func _target_name_to_target(target_name):

	if not Available::TARGETS.find(target_name):
		_error(Strings::format("No support yet for target '%s'.", target_name))

	return Available::TARGETS[target_name].new()




func main():

	if Sys::argv.len() > 1 & Sys::argv[0] == "-l":
		Library_Linker.new()
	else:
		Linker.new()
