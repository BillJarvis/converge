// Copyright (c) 2006 King's College London, created by Laurence Tratt
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.


import Platform::Properties
import Builtins, Bytecode_Gen, Compiler_Vars, CV_Module, CV_Parser, File, Functional, IModule_Gen, ITree, Strings, Targets::Available, Tokenizer, VM




class Eval_Compiler:

	func init(self, str, vars, includes):
	
		self._str := str
		self.vars := vars
		
		self.bootstrap := 0
		self.includes := includes
		self.module_id := Strings::format(Compiler_Vars::UNIQUE_EVAL_NAME_TEMPLATE, Compiler_Vars::fresh_name())
		self.target := Available::TARGETS[Strings::format("%dbit", Properties::word_bits)].new()



	func eval(self):
		
		self.tokenizer := Tokenizer::Tokenizer.new()
		parse_tree := CV_Parser::parse_expr(self._str)
		self.newlines := self.tokenizer.newlines
		
		body := []
		
		compiler_var_name := Compiler_Vars::fresh_name()
		compiler_var := ITree::IVar.new(compiler_var_name, [])
		peek_compiler := ITree::IModule_Lookup.new([ITree::IMod_Id_Import.new(Compiler_Vars.module_id, []), ITree::IVar.new("peek_compiler", [])], [])
		body.append(ITree::IAssignment.new(ITree::STD_ASSIGN, [compiler_var], ITree::IApplication.new(peek_compiler, [], []), []))
		
		vars_val := ITree::ISlot_Lookup.new(compiler_var, "vars", [])
		for var_name, _ := self.vars.iterate():
			var_val := ITree::IApplication.new(ITree::ISlot_Lookup.new(vars_val, "get", []), [ITree::IString.new(var_name, [])], [])
			body.append(ITree::IAssignment.new(ITree::STD_ASSIGN, [ITree::IVar.new(var_name, [])], var_val, []))

		expr := IModule_Gen::IModule_Gen.new().generate(parse_tree)

		dict_vals := []
		for var_name, var_val := self.vars.iterate():
			dict_vals.append([ITree::IString.new(var_name, []), ITree::IVar.new(var_name, [])])
		rtn_dict := ITree::IDict.new(dict_vals, [])

		vars_assign := []
		vars_assign_names := Set{}
		for var_name, _ := self.vars.iterate():
			vars_assign_names.add(var_name)
		vars_assign_names.extend(expr.bound_vars)
		for var_name := vars_assign_names.iterate():
			var_val := ITree::IApplication.new(ITree::ISlot_Lookup.new(vars_val, "set", []), [ITree::IString.new(var_name, []), ITree::IVar.new(var_name, [])], [])
			vars_assign.append(var_val)

		body.append([|
			if rtn := ${expr}:
				${vars_assign}
				return rtn
			else:
				${vars_assign}
				return fail
		|])

		eval_name := Compiler_Vars::fresh_name()		
		dummy_func := ITree::IFunc_Def.new(0, eval_name, [], null, [], [], ITree::IExpr_Block.new(body, []), [])
		dummy_definitions := [ITree::IAssignment.new(ITree::STD_ASSIGN, [ITree::IVar.new(eval_name, [])], dummy_func, [])]
		dummy_imodule := ITree::IModule.new(eval_name, dummy_definitions, [])
		
		cv_mod := _Eval_Bytecode_Gen.new().generate(dummy_imodule, self.target)
		mod := Builtins::Module.new(cv_mod.serialize())
		
		module_identifiers := VM::add_modules([mod])
		VM::import_module(cv_mod.get_identifier())
		
		return mod.get_def(eval_name)()



	func find_import_location(self, import_name_list):

		func match_path(i, dir):
		
			cnd_path := File::join_names(dir, import_name_list[i])

			if File::exists(cnd_path) & File::is_dir(cnd_path):
				if i + 1 == import_name_list.len():
					return [cnd_path, i]
				else:
					return match_path(i + 1, cnd_path)

			cnd_file_path := File::join_ext(cnd_path, CV_Module::CV_EXTENSION)
			if File::exists(cnd_file_path) & File::is_file(cnd_file_path):
				return [cnd_file_path, i]
			
			return fail
			
	
		for include_dir := self.includes.iterate():
			if matched_path, extra_pos := match_path(0, include_dir):
				import_full_name := File::canon_path(matched_path)
				import_extras := import_name_list[extra_pos + 1 : ]
				break
		exhausted:
			if self.bootstrap == 1:
				// If we're in bootstrapping mode, we see if we can import the module from the VM
				// i.e. whether it's a builtin module or not.
				import_full_name := import_name_list[0]
				VM.import_module(import_full_name)
				import_extras := import_name_list[1 : ]
			elif Compiler_Vars::BUILTIN_MODULES.find(import_name_list[0]):
				import_full_name := import_name_list[0]
				import_extras := import_name_list[1 : ]
			else:
				return fail
		
		return [import_full_name, import_extras]




class _Eval_Bytecode_Gen(Bytecode_Gen::Bytecode_Gen):

	func _prc_mod_lookup(self, mod_lookup):

		assert _Eval_Compiler.instantiated(self._compiler)

		if not (val := self._compiler.vars.find(mod_lookup.names[0].var_name)):
			// Since this doesn't even refer to a valid variable, a "variable not found" error will
			// be raised elsewhere, so we don't bother dealing with it here.
			return

		if not Builtins::Module.instantiated(val):
			self._compiler.warning("Unable to determine module referenced in lookup (use a plain variable lookup instead)", mod_lookup.names[0].src_infos)




func eval(str, vars := Dict{}, includes := []):

	compiler := Eval_Compiler.new(str, vars, includes)
	Compiler_Vars::push_compiler(compiler)
	if not (result := compiler.eval()):
		Compiler_Vars::pop_compiler()
		return fail
	else:
		Compiler_Vars::pop_compiler()
		return result
