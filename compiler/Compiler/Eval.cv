// Copyright (c) 2006 King's College London, created by Laurence Tratt
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.


import Platform::Properties
import Builtins, Bytecode_Gen, Compiler_Vars, CV_Module, CV_Parser, File, Functional, IModule_Gen, ITree, Strings, Targets::Available, Tokenizer, VM




class Eval_Compiler:

	func init(self, str, vars, includes):
	
		self._str := str
		self.vars := vars
		
		self.bootstrap := 0
		self.includes := includes
		self.module_id := Strings::format(Compiler_Vars::UNIQUE_EVAL_NAME_TEMPLATE, Compiler_Vars::fresh_name())
		self.internal_target := self.target := Available::TARGETS[Strings::format("%dbit", Properties::word_bits)].new()



	func eval(self):
		
		self.tokenizer := Tokenizer::Tokenizer.new()
		parse_tree := CV_Parser::parse_expr(self._str)
		self.newlines := self.tokenizer.newlines
		
		body := []
		
		compiler_var_name := Compiler_Vars::fresh_name()
		compiler_var := ITree::IVar.new(compiler_var_name, [])
		peek_compiler := ITree::IModule_Lookup.new([ITree::IMod_Id_Import.new(Compiler_Vars.module_id, []), ITree::IVar.new("peek_compiler", [])], [])
		body.append(ITree::IAssignment.new(ITree::STD_ASSIGN, [compiler_var], ITree::IApplication.new(peek_compiler, [], []), []))
		
		vars_val := ITree::ISlot_Lookup.new(compiler_var, "vars", [])
		for var_name, _ := self.vars.iter():
			var_val := ITree::IApplication.new(ITree::ISlot_Lookup.new(vars_val, "get", []), [ITree::IString.new(var_name, [])], [])
			body.append(ITree::IAssignment.new(ITree::STD_ASSIGN, [ITree::IVar.new(var_name, [])], var_val, []))

		expr := IModule_Gen::IModule_Gen.new().generate(parse_tree)

		dict_vals := []
		for var_name, var_val := self.vars.iter():
			dict_vals.append([ITree::IString.new(var_name, []), ITree::IVar.new(var_name, [])])
		rtn_dict := ITree::IDict.new(dict_vals, [])

		vars_assign := []
		vars_assign_names := Set{}
		for var_name, _ := self.vars.iter():
			vars_assign_names.add(var_name)
		vars_assign_names.extend(expr.bound_vars)
		for var_name := vars_assign_names.iter():
			var_val := ITree::IApplication.new(ITree::ISlot_Lookup.new(vars_val, "set", []), [ITree::IString.new(var_name, []), ITree::IVar.new(var_name, [])], [])
			vars_assign.append(var_val)

		body.append([|
			if rtn := ${expr}:
				${vars_assign}
				return rtn
			else:
				${vars_assign}
				return fail
		|])

		eval_name := Compiler_Vars::fresh_name()		
		dummy_func := ITree::IFunc_Defn.new(0, ITree::IVar.new(eval_name, []), [], null, [], [], ITree::IExpr_Block.new(body, []), [])
		dummy_defns := [ITree::IAssignment.new(ITree::STD_ASSIGN, [ITree::IVar.new(eval_name, [])], dummy_func, [])]
		dummy_imodule := ITree::IModule.new(eval_name, dummy_defns, [])
		
		cv_mod := _Eval_Bytecode_Gen.new().generate(dummy_imodule, self.target)
		mod := Builtins::Module.new(cv_mod.serialize())
		
		cv_mod_stack := [cv_mod]
		mod_stack := [mod]
		mod_ids := Set{}
		i := 0
		while i < mod_stack.len():
			cv_mod := cv_mod_stack[i]
			for import_ := cv_mod.get_imports().iter():
				if not VM::find_module(import_) & not mod_ids.find(import_):
					cv_mod := self.get_cv_mod(import_, [])
					cv_mod_stack.append(cv_mod)
					mod_stack.append(Builtins::Module.new(cv_mod.serialize()))
					mod_ids.add(import_)

			i += 1
		
		VM::add_modules(mod_stack)
		main_mod := VM::import_module(mod_stack[0])
		for mod := mod_stack.iter(1):
			VM::import_module(mod)
		
		return main_mod.get_defn(eval_name)()



	func find_import_location(self, import_name_list):

		func match_path(i, dir):
		
			cnd_path := File::join_names(dir, import_name_list[i])

			if File::exists(cnd_path) & File::is_dir(cnd_path):
				if i + 1 == import_name_list.len():
					return [cnd_path, i]
				else:
					return match_path(i + 1, cnd_path)

			cnd_file_path := File::join_ext(cnd_path, CV_Module::CV_EXTENSION)
			if File::exists(cnd_file_path) & File::is_file(cnd_file_path):
				return [cnd_file_path, i]
			
			return fail
			
	
		for include_dir := self.includes.iter():
			if matched_path, extra_pos := match_path(0, include_dir):
				import_full_name := File::canon_path(matched_path)
				import_extras := import_name_list[extra_pos + 1 : ]
				break
		exhausted:
			// If the first part of the import references a builtin, then looking up that module ID
			// will succeed.
			if VM::find_module(import_name_list[0]):
				import_full_name := import_name_list[0]
				import_extras := import_name_list[1 : ]
			else:
				return fail
		
		return [import_full_name, import_extras]



	func get_cv_mod(self, src_path, src_infos):

		name, ext := File::split_ext(src_path)
		if ext == Compiler_Vars::CV_EXTENSION:
			cvb_path := File::join_ext(name, Compiler_Vars::CVB_EXTENSION)
			if File::exists(cvb_path):
				cvb_file := File::open(cvb_path, "r")
				cvb_data := cvb_file.read()
				cvb_file.close()
				if cvb_data.prefixed_by(CV_Module::MODULE_INIT_STRING):
					mod := CV_Module::CV_Module.new(self.target)
					mod.deserialize_str(cvb_data)
					return mod
		
		self.error(Strings::format("Unable to import '%s'.", src_path), src_infos)




class _Eval_Bytecode_Gen(Bytecode_Gen::Bytecode_Gen):

	func _prc_mod_lookup(self, mod_lookup):

		assert _Eval_Compiler.instantiated(self._compiler)

		if not (val := self._compiler.vars.find(mod_lookup.names[0].var_name)):
			// Since this doesn't even refer to a valid variable, a "variable not found" error will
			// be raised elsewhere, so we don't bother dealing with it here.
			return

		if not Builtins::Module.instantiated(val):
			self._compiler.warning("Unable to determine module referenced in lookup (use a plain variable lookup instead)", mod_lookup.names[0].src_infos)




func eval(str, vars := Dict{}, includes := []):

	compiler := Eval_Compiler.new(str, vars, includes)
	Compiler_Vars::push_compiler(compiler)
	if not (result := compiler.eval()):
		Compiler_Vars::pop_compiler()
		return fail
	else:
		Compiler_Vars::pop_compiler()
		return result
