// Copyright (c) 2006 King's College London, created by Laurence Tratt
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.


import Platform::Properties
import Builtins, Bytecode_Gen, Compiler_Vars, CV_Parser, IModule_Gen, ITree, Strings, Targets::Available, Tokenizer, VM




class _Eval_Compiler:

	func init(self, str, vars, includes):
	
		self._str := str
		self._vars := vars
		
		self.bootstrap := 0
		self.includes := includes
		self.src_path := "<eval>"
		self.module_id := Strings::format(Compiler_Vars::UNIQUE_EVAL_NAME_TEMPLATE, Compiler_Vars::fresh_name())
		self.target := Available::TARGETS[Strings::format("%dbit", Properties::word_bits)].new()



	func eval(self):
		
		self.tokenizer := Tokenizer::Tokenizer.new()
		parse_tree := CV_Parser::parse_expr(self._str)
		self.newlines := self.tokenizer.newlines

		body := []
		
		compiler_var_name := Compiler_Vars::fresh_name()
		compiler_var := ITree::IVar.new(compiler_var_name, [])
		peek_compiler := ITree::IModule_Lookup.new([ITree::IMod_Id_Import.new(Compiler_Vars.module_id, []), ITree::IVar.new("peek_compiler", [])], [])
		body.append(ITree::IAssignment.new(ITree::STD_ASSIGN, [compiler_var], ITree::IApplication.new(peek_compiler, [], []), []))
		
		vars_val := ITree::ISlot_Lookup.new(compiler_var, "_vars", [])
		for var_name, _ := self._vars.iterate():
			var_val := ITree::IApplication.new(ITree::ISlot_Lookup.new(vars_val, "get", []), [ITree::IString.new(var_name, [])], [])
			body.append(ITree::IAssignment.new(ITree::STD_ASSIGN, [ITree::IVar.new(var_name, [])], var_val, []))

		expr := IModule_Gen::IModule_Gen.new().generate(parse_tree)

		dict_vals := []
		for var_name, var_val := self._vars.iterate():
			dict_vals.append([ITree::IString.new(var_name, []), ITree::IVar.new(var_name, [])])
		rtn_dict := ITree::IDict.new(dict_vals, [])

		vars_assign := []
		vars_assign_names := Set{}
		for var_name, _ := self._vars.iterate():
			vars_assign_names.add(var_name)
		vars_assign_names.extend(expr.bound_vars)
		for var_name := vars_assign_names.iterate():
			var_val := ITree::IApplication.new(ITree::ISlot_Lookup.new(vars_val, "set", []), [ITree::IString.new(var_name, []), ITree::IVar.new(var_name, [])], [])
			vars_assign.append(var_val)

		body.append([|
			if rtn := ${expr}:
				${vars_assign}
				return rtn
			else:
				${vars_assign}
				return fail
		|])

		eval_name := Compiler_Vars::fresh_name()		
		dummy_func := ITree::IFunc_Def.new(0, eval_name, [], null, [], [], ITree::IExpr_Block.new(body, []), [])
		dummy_definitions := [ITree::IAssignment.new(ITree::STD_ASSIGN, [ITree::IVar.new(eval_name, [])], dummy_func, [])]
		dummy_imodule := ITree::IModule.new(eval_name, dummy_definitions, [])
		
		cv_mod := Bytecode_Gen::Bytecode_Gen.new().generate(dummy_imodule, self.target)
		mod := Builtins::Module.new(cv_mod.serialize())
		
		module_identifiers := VM::add_modules([mod])
		VM::import_module(cv_mod.get_identifier())
		
		return mod.get_def(eval_name)()



	func find_import_location(self, import_name_list):

		if Compiler_Vars::BUILTIN_MODULES.find(import_name_list[0]):
			import_full_name := import_name_list[0]
			import_extras := import_name_list[1 : ]
		else:
			raise "XXX"

		return [import_full_name, import_extras]




func eval(str, vars := Dict{}, includes := []):

	compiler := _Eval_Compiler.new(str, vars, includes)
	Compiler_Vars::push_compiler(compiler)
	if not (result := compiler.eval()):
		Compiler_Vars::pop_compiler()
		return fail
	else:
		Compiler_Vars::pop_compiler()
		return result
