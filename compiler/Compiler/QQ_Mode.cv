// Copyright (c) 2003-2006 King's College London, created by Laurence Tratt
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.


import Builtins, Strings
import Compiler_Vars, ITree, ITree_TC, Lift




_QQ_STANDARD := 0
_QQ_DEFINITION := 1

_NEST_CLASS := 0
_NEST_FUNC := 1




class QQ_Mode:

	func generate(self, parent_mode, node):
	
		self.parent_mode := parent_mode
		
		// 'closures' is exactly as in Bytecode_Gen; see that file for descriptions of
		// them.
		
		self.closures := []
		
		// These next two slots are purely for convenience.

		self._compiler := Compiler_Vars::peek_compiler()
		self._module_id := self._compiler.module_id
		
		// We need to track when we're dealing with class fields or not. So we track when we're nested
		// within nothing (i.e. at the top level), a class (meaning we're at the class field level
		// when we don't alpha rename functions or classes), or within a function (meaning we can
		// merrily alpha rename things).
		
		self._nesting := []
		
		if ITree::IStandard_Quasi_Quotes.instantiated(node):
			self._type := _QQ_STANDARD

			// To build up a normal quasi-quotes statement we construct a conjunction whose first
			// elements safeguard variables bound in the quasi-quotes, and whose last element(s)
			// construct the ITree itself.
			//
			// e.g.
			//
			//   [|
			//     x := 2
			//     Sys.println(x)
			//   |]
			//
			// gets converted to something along the lines of:
			//
			//   $$qq$$x$$ := CEI::fresh_name("x") | [CEI.iassignment(..., [CEI::ivar($$qq$$x$$)],
			//     CEI::iint(2)), CEI::iapplication(CEI::islot_lookup(CEI::ivar("Sys"), "println"),
			//     [CEI::ivar($$qq$$x$$)])]

			return_exprs := []
			
			if not node.extra_src_infos is null:
				self._extra_src_infos_var := ITree::IVar.new(node.extra_src_infos_var_name, node.src_infos)
				return_exprs.append(ITree::IAssignment.new(ITree::STD_ASSIGN, [self._extra_src_infos_var], node.extra_src_infos, node.src_infos))
			else:
				self._extra_src_infos_var := null

			vars := Set{}
			for var := node.body.exprs.iterate():
				vars.extend(var.qq_bound_vars)
			self._add_vars(vars, [])
			
			// We now do the $$qq$x$$ := CEI::fresh_name("x") constrution.
			//
			// Note that it might seem unsafe to do things in this fashion, since two consecutive
			// quasi-quotes could use the same $$qq$$...$$ name. e.g.:
			//
			//   [| x := 2 |]
			//
			//   [| x := 3 |]
			//
			// The two x's might "clash" and there may be a chance to trick the VM into using a
			// previous value of $$qq$$x$$ instead of giving an unused variable error. In fact,
			// this isn't a problem because QQ_Mode guarantees to initialise all $$qq$$..$$
			// variables each time it constructs an ITree. One can view the reuse of the $$qq$$x$$
			// variable above as an optimisation (although that is perhaps making a virtue out of
			// a very convenient necessity).
			
			for var_name := node.qq_bound_vars.iterate():
				if not node.extra_src_infos is null & var_name == node.extra_src_infos_var_name:
					continue
				
				qq_bound_var := ITree::IVar.new(var_name, node.src_infos)
				fresh_name_func := self._get_module_def_at_qq("Compiler_Vars", "fresh_name", node.src_infos)
				fresh_name := ITree::IApplication.new(fresh_name_func, [ITree::IString.new(var_name, node.src_infos)], node.src_infos)
				return_exprs.append(ITree::IAssignment.new(ITree::STD_ASSIGN, [qq_bound_var], fresh_name, node.src_infos))

			e := self._lift_func_call(_expr_block_magic, [self._eval_expr_block(node.body)], node.src_infos)
			ITree_TC::tc(e)
			return_exprs.append(e)

			// We don't strictly need to pop the last lot of variables, but do so for completeness.
			
			self._pop_vars()

			return ITree::IConjunction.new(return_exprs, node.src_infos)
		else:
			raise "XXX"



	func _add_vars(self, vars, renames):
	
		vars_dict := Dict{}
		for var := vars.iterate():
			vars_dict[var] := vars_dict.len()

		self.closures.append([vars_dict, renames])



	func _pop_vars(self):
	
		self.closures.del(-1)



	func _qq_bound_var_name(self, var_name):
	
		return Strings::format(Compiler_Vars::QUASI_QUOTES_NAME, var_name)
	
	
	
	func _qq(self, node_type, args, node_src_infos):

		src_infos := []
		for src_file, src_offset := node_src_infos.iterate():
			src_infos.append(ITree::IList.new([ITree::IString.new(src_file, node_src_infos), ITree::IInt.new(src_offset, node_src_infos)], node_src_infos))
		
		full_src_infos := ITree::IList.new(src_infos, node_src_infos)
		if not self._extra_src_infos_var is null:
			full_src_infos := ITree::IBinary.new(ITree::BINARY_ADD, full_src_infos, self._extra_src_infos_var, node_src_infos)

		itree_node := ITree::ISlot_Lookup.new(self._get_module_def_at_qq("ITree", node_type, node_src_infos), "new", node_src_infos)
		return ITree::IApplication.new(itree_node, args + [full_src_infos], node_src_infos)



	func _get_var_offset(self, var_name, src_infos):

		mode := self
		while not mode is null:
			i := mode.closures.len() - 1
			search_var_name := var_name
			while i >= 0:
				if mode.closures[i][Compiler_Vars::CLOSURE_VARS].find(search_var_name):
					break
				if rename_as := mode.closures[i][Compiler_Vars::CLOSURE_RENAMES].find(search_var_name):
					search_var_name := rename_as
				i -= 1
			broken:
				return [search_var_name, mode, i]
			
			mode := mode.parent_mode
		exhausted:
			self._compiler.error(Strings::format("Unknown variable '%s'.", var_name), src_infos)



	func _process_lookup_var(self, var_name, node_src_infos):

		renamed_var_name, mode, i := self._get_var_offset(var_name, node_src_infos)
		
		if not mode is self:
			// This variable is outside of the quasi-quotes.
			if mode.parent_mode is null & i == 0:
				mod_id_import := self._qq("IMod_Id_Import", [ITree::IString.new(self._module_id, node_src_infos)], node_src_infos)
				defn_name := self._qq("IVar", [ITree::IString.new(renamed_var_name, node_src_infos)], node_src_infos)
				mod_lookup_names := ITree::IList.new([mod_id_import, defn_name], node_src_infos)
				return self._qq("IModule_Lookup", [mod_lookup_names], node_src_infos)
			else:
				self._compiler.error(Strings::format("Trying to reference variable '%s' which is not defined in the outer-most scope.", var_name), node_src_infos)
		
		assert(var_name == renamed_var_name)
		
		return self._qq("IVar", [ITree::IVar.new(self._qq_bound_var_name(var_name), node_src_infos)], node_src_infos)



	func _process_assign_name(self, var_name, node_src_infos):

		renamed_var_name, mode, i := self._get_var_offset(var_name, node_src_infos)
		
		if not mode is self:
			raise "XXX"

		assert(var_name == renamed_var_name)
		
		if self._nesting.len() > 0 & self._nesting[-1] == _NEST_CLASS:
			return ITree::IVar.new(var_name, node_src_infos)
		else:
			return ITree::IVar.new(self._qq_bound_var_name(var_name), node_src_infos)



	func _process_assign_var(self, var_name, node_src_infos):

		return self._qq("IVar", [self._process_assign_name(var_name, node_src_infos)], node_src_infos)



	//
	// Return an IOriginal_Name which looks up 'defn_name' in the module named 'module_name' in the
	// Converge compiler.
	//
	
	func _get_module_def_at_qq(self, module_name, defn_name, src_infos):
	
		if not module_id, import_extras := self._compiler.find_import_location(["Compiler", module_name]):
			raise "XXX"
				
		if import_extras.len() > 0:
			raise "XXX"
		
		mod_id_import := ITree::IMod_Id_Import.new(module_id, src_infos)
		return ITree::IModule_Lookup.new([mod_id_import, ITree::IVar.new(defn_name, src_infos)], src_infos)



	//
	// Lift the function call "f.apply(args)". 'f' should be a reference to a real function, which
	// must be a top-level definition in a module.
	//

	func _lift_func_call(self, f, args, src_infos):
	
		if not Builtins::Module.instantiated(f.container):
			raise "XXX"
		
		mod_id_import := ITree::IMod_Id_Import.new(f.container.module_id, src_infos)
		func_ref := ITree::IModule_Lookup.new([mod_id_import, ITree::IVar.new(f.name, src_infos)], src_infos)
		
		return ITree::IApplication.new(func_ref, args, src_infos)



	//
	// Return an ITree of a list of expressions representing the quasi-quoted expression block 'node'.
	//

	func _eval_expr_block(self, node):

		block := []
		contains_iinsert := 0
		for expr := node.exprs.iterate():
			if ITree::IInsert.instantiated(expr):
				// We need to check the result of an IInsert at "run-time". In an expression block,
				// it's perfectly legitimite for an insert to return a list. So at "run-time" have
				// to check if we've got a list, in which case we check that each element of the
				// list is an expression; if it's not a list, we check that the returned element
				// itself is an expression.
				block.append(self._lift_func_call(_expr_block_insert, [expr.expr, Lift::lift(expr.src_infos)], expr.src_infos))
				contains_iinsert := 1
			else:
				block.append(self._preorder(expr))
		
		list := ITree::IList.new(block, node.src_infos)
		if contains_iinsert == 1:
			exprs := ITree::IApplication.new(ITree::ISlot_Lookup.new(list, "flattened", node.src_infos), [], node.src_infos)
		else:
			exprs := list

		return exprs

		


	/////////////////////////////////////////////////////////////////////////////////////////////////
	// Node traversal
	//

	func _preorder(self, node):
	
		return self.get_slot("_t_" + node.instance_of.name.to_lower_case())(node)



	func _t_iclass_def(self, node):

		if ITree::IInsert.instantiated(node.class_name):
			// Class names are a little odd because the class "name" is also used as a variable
			// to be assigned to. The class name is actually just the string part of this variable
			// name, which means we have to manually pluck it out. If the user gives us a variable
			// which isn't of type IVar, they would get an odd error message along the lines of
			// "1 doesn't have a class_name slot" which wouldn't really help them track things down.
			// To cope with this eventuality, we put a manual check in that catches such an error
			// at the earliest possible stage.
			class_name := self._lift_func_call(_class_name, [node.class_name.expr, Lift::lift(node.src_infos)], node.src_infos)
		else:
			if node.class_name == "":
				class_name := ITree::IString.new("", node.src_infos)
			else:
				if self._nesting.len() > 0 & self._nesting[-1] == _NEST_CLASS:
					// Classes which are class fields are not alpha-renamed.
					class_name := ITree::IString.new(node.class_name, node.src_infos)
				else:
					class_name := self._process_assign_name(node.class_name, node.src_infos)

		supers := []
		for super := node.supers.iterate():
			supers.append(self._preorder(super))
		
		if node.metaclass_ is null:
			metaclass_ := ITree::IVar.new("null", node.src_infos)
		else:
			metaclass_ := self._preorder(node.metaclass_)

		// Note that it is only when processing the classes field that we note that we are nested
		// within a class.
				
		self._nesting.append(_NEST_CLASS)
		
		fields := []
		for field := node.fields.iterate():
			fields.append(self._preorder(field))
		
		self._nesting.pop()
		
		return self._qq("IClass_Def", [class_name, ITree::IList.new(supers, node.src_infos), metaclass_, ITree::IList.new(fields, node.src_infos)], node.src_infos)



	func _t_ifunc_def(self, node):

		is_bound := ITree::IInt.new(node.is_bound, node.src_infos)
		if ITree::IInsert.instantiated(node.func_name):
			// Function names are a little odd because the function "name" is also used as a variable
			// to be assigned to. The function name is actually just the string part of this variable
			// name, which means we have to manually pluck it out. If the user gives us a variable
			// which isn't of type IVar, they would get an odd error message along the lines of
			// "1 doesn't have a func_name slot" which wouldn't really help them track things down.
			// To cope with this eventuality, we put a manual check in that catches such an error
			// at the earliest possible stage.
			func_name := self._lift_func_call(_func_name, [node.func_name.expr, Lift::lift(node.src_infos)], node.src_infos)
		else:
			if node.func_name == "":
				func_name := ITree::IString.new("", node.src_infos)
			else:
				if self._nesting.len() > 0 & self._nesting[-1] == _NEST_CLASS:
					// Functions which are class fields are not alpha-renamed.
					func_name := ITree::IString.new(node.func_name, node.src_infos)
				else:
					func_name := self._process_assign_name(node.func_name, node.src_infos)

		// Note that we consider ourselves nested within a function even when processing parameters.

		self._nesting.append(_NEST_FUNC)

		self._add_vars(node.internal_bound_vars, [])

		params_list := []
		for param := node.params.iterate():
			if ITree::IParam.instantiated(param):
				var := self._preorder(param.var)
				if param.default is null:
					default := ITree::IVar.new("null", param.src_infos)
				else:
					// When we're processing a parameter, we're converting its name from a string
					// "x" to a variable lookup "$qq_x".
					default := ITree::IVar.new(self._qq_bound_var_name(var.var_name), param.src_infos)
				params_list.append(self._qq("IParam", [var, default], param.src_infos))
			else:
				assert ITree::IInsert.instantiated(param)
				params_list.append(param.expr)
		
		params := ITree::IApplication.new(ITree::ISlot_Lookup.new(ITree::IList.new(params_list, node.src_infos), "flattened", node.src_infos), [], node.src_infos)
		
		if node.var_arg is null:
			var_arg := ITree::IVar.new("null", node.src_infos)
		elif ITree::IInsert.instantiated(node.var_arg):
			var_arg := node.var_arg.expr
		else:
			var_arg := self._process_assign_var(node.var_arg.var_name, node.src_infos)
		
		nonlocals := []
		for nonlocal_ := node.nonlocals.iterate():
			raise "XXX"
		
		renames := []
		for rename_ := node.renames.iterate():
			raise "XXX"
		
		body := self._preorder(node.body)

		self._pop_vars()
		self._nesting.pop()
		
		return self._qq("IFunc_Def", [is_bound, func_name, params, var_arg, ITree::IList.new(nonlocals, node.src_infos), ITree::IList.new(renames, node.src_infos), body], node.src_infos)



	func _t_iexpr_block(self, node):
	
		return self._qq("IExpr_Block", [self._eval_expr_block(node)], node.src_infos)



	func _t_iif(self, node):

		clauses := []
		for clause := node.clauses.iterate():
			clauses.append(self._preorder(clause))
		
		if node.else_body is null:
			else_body := ITree::IVar.new("null", node.src_infos)
		else:
			else_body := self._preorder(node.else_body)
		
		return self._qq("IIf", [ITree::IList.new(clauses, node.src_infos), else_body], node.src_infos)



	func _t_indif(self, node):

		clauses := []
		for clause := node.clauses.iterate():
			clauses.append(self._preorder(clause))
		
		return self._qq("INDIf", [ITree::IList.new(clauses, node.src_infos)], node.src_infos)



	func _t_iclause(self, node):
	
		return self._qq("IClause", [self._preorder(node.condition), self._preorder(node.body)], node.src_infos)



	func _t_iint(self, node):

		return self._qq("IInt", [node], node.src_infos)



	func _t_ivar(self, node):

		return self._process_lookup_var(node.var_name, node.src_infos)



	func _t_istring(self, node):

		return self._qq("IString", [node], node.src_infos)



	func _t_islot_lookup(self, node):

		return self._qq("ISlot_Lookup", [self._preorder(node.object_expr), ITree::IString.new(node.slot_name, node.src_infos)], node.src_infos)



	func _t_imodule_lookup(self, node):

		assert(ITree::IVar.instantiated(node.names[0]))

		names := []

		if ITree::IInsert.instantiated(node.names[0]):
			names.append(node.names[0].expr)
		else:
			// We need to process the first part of a module lookup differently. If we've got code along
			// the lines of the following:
			//
			//   import Builtins
			//
			//   func f():
			//     return [| Builtins::String |]
			//
			// then we want to unpack the quasi-quoted module lookup so that it becomes:
			//
			//   [Mod_Id_Import(Builtins), IVar(String)]
			//
			// This means we have to manually deal with the variable which constitutes the first entry in
			// a module lookup.

			var_name := node.names[0].var_name
			renamed_var_name, mode, i := self._get_var_offset(var_name, node.src_infos)
			if not mode is self:
				// Variable is outside of the quasi-quotes.
				if mode.parent_mode is null & i == 0:
					// This is where we do the unpacking mentioned above.
					names.append(self._qq("IMod_Id_Import", [ITree::IString.new(self._module_id, node.src_infos)], node.src_infos))
					names.append(self._qq("IVar", [ITree::IString.new(renamed_var_name, node.src_infos)], node.src_infos))
				else:
					self._compiler.error(Strings::format("Trying to reference variable '%s' which is not defined in the outer-most scope.", var_name), node.src_infos)
			else:
				// Variable is inside the quasi-quotes.
				names.append(self._qq("IVar", [ITree::IString.new(renamed_var_name, node.src_infos)], node.src_infos))

		// Processing all

		for name := node.names.iterate(1):
			if ITree::IInsert.instantiated(name):
				qq_name := name.expr
			else:
				qq_name := self._qq("IVar", [ITree::IString.new(name.var_name, name.src_infos)], name.src_infos)
			names.append(qq_name)

		return self._qq("IModule_Lookup", [ITree::IList.new(names, node.src_infos)], node.src_infos)



	func _t_ilist(self, node):

		elems := []
		for elem := node.elements.iterate():
			elems.append(self._preorder(elem))
		
		return self._qq("IList", [ITree::IList.new(elems, node.src_infos)], node.src_infos)



	func _t_idict(self, node):

		elems := []
		for key, val := node.elements.iterate():
			elems.append(ITree::IList.new([self._preorder(key), self._preorder(val)], node.src_infos))
		
		return self._qq("IDict", [ITree::IList.new(elems, node.src_infos)], node.src_infos)



	func _t_iset(self, node):

		elems := []
		for elem := node.elements.iterate():
			elems.append(self._preorder(elem))
		
		return self._qq("ISet", [ITree::IList.new(elems, node.src_infos)], node.src_infos)



	func _t_iapplication(self, node):

		func_expr := self._preorder(node.func_expr)
		args := []
		for arg := node.args.iterate():
			args.append(self._preorder(arg))
		
		return self._qq("IApplication", [func_expr, ITree::IList.new(args, node.src_infos)], node.src_infos)



	func _t_iget(self, node):
		
		return self._qq("IGet", [self._preorder(node.get_object), self._preorder(node.index)], node.src_infos)



	func _t_islice(self, node):

		slice_object := self._preorder(node.slice_object)
		
		if node.lower_bound is null:
			lower_bound := ITree::IVar.new("null", node.src_infos)
		else:
			lower_bound := self._preorder(node.lower_bound)
		
		if node.upper_bound is null:
			upper_bound := ITree::IVar.new("null", node.src_infos)	
		else:
			upper_bound := self._preorder(node.upper_bound)
			
		return self._qq("ISlice", [slice_object, lower_bound, upper_bound], node.src_infos)



	func _t_ireturn(self, node):
	
		if node.return_expr is null:
			return self._qq("IReturn", [ITree::IVar.new("null", node.src_infos)], node.src_infos)
		else:
			return self._qq("IReturn", [self._preorder(node.return_expr)], node.src_infos)



	func _t_iyield(self, node):
	
		return self._qq("IYield", [self._preorder(node.yield_expr)], node.src_infos)



	func _t_iraise(self, node):
	
		return self._qq("IRaise", [self._preorder(node.raise_expr)], node.src_infos)



	func _t_iassert(self, node):

		return self._qq("IAssert", [self._preorder(node.assert_expr)], node.src_infos)



	func _t_ibreak(self, node):

		return self._qq("IBreak", [], node.src_infos)



	func _t_icontinue(self, node):

		return self._qq("IContinue", [], node.src_infos)



	func _t_iconjunction(self, node):
	
		exprs := []
		for expr := node.exprs.iterate():
			exprs.append(self._preorder(expr))
		
		return self._qq("IConjunction", [ITree::IList.new(exprs, node.src_infos)], node.src_infos)



	func _t_ialternation(self, node):

		exprs := []
		for expr := node.exprs.iterate():
			exprs.append(self._preorder(expr))

		return self._qq("IAlternation", [ITree::IList.new(exprs, node.src_infos)], node.src_infos)



	func _t_iassignment(self, node):

		targets := []
		for target := node.targets.iterate():
			if ITree::IVar.instantiated(target):
				if self._nesting.len() > 0 & self._nesting[-1] == _NEST_CLASS:
					targets.append(self._qq("IVar", [ITree::IString.new(target.var_name, node.src_infos)], node.src_infos))
				else:
					targets.append(self._process_assign_var(target.var_name, target.src_infos))
			else:
				targets.append(self._preorder(target))

		return self._qq("IAssignment", [ITree::IInt.new(node.type, node.src_infos), ITree::IList.new(targets, node.src_infos), self._preorder(node.expr)], node.src_infos)



	func _t_inot(self, node):
	
		return self._qq("INot", [self._preorder(node.expr)], node.src_infos)



	func _t_ibinary(self, node):
	
		return self._qq("IBinary", [ITree::IInt.new(node.type, node.src_infos), self._preorder(node.lhs), self._preorder(node.rhs)], node.src_infos)



	func _t_icomparison(self, node):
	
		return self._qq("IComparison", [ITree::IInt.new(node.type, node.src_infos), self._preorder(node.lhs), self._preorder(node.rhs)], node.src_infos)



	func _t_ipass(self, node):
	
		return self._qq("IPass", [], node.src_infos)



	func _t_iimport(self, node):
	
		return self._qq("IImport", [ITree::IString.new(node.module_path, node.src_infos), ITree::IString.new(node.var_name, node.src_infos)], node.src_infos)



	func _t_iwhile(self, node):

		condition := self._preorder(node.condition)

		if node.body is null:
			body := ITree::IVar.new("null", node.src_infos)
		else:
			body := self._preorder(node.body)

		if node.exhausted_body is null:
			exhausted_body := ITree::IVar.new("null", node.src_infos)
		else:
			exhausted_body := self._preorder(node.exhausted_body)

		if node.broken_body is null:
			broken_body := ITree::IVar.new("null", node.src_infos)
		else:
			broken_body := self._preorder(node.broken_body)

		return self._qq("IWhile", [condition, body, exhausted_body, broken_body], node.src_infos)



	func _t_ifor(self, node):

		condition := self._preorder(node.condition)

		if node.body is null:
			body := ITree::IVar.new("null", node.src_infos)
		else:
			body := self._preorder(node.body)

		if node.exhausted_body is null:
			exhausted_body := ITree::IVar.new("null", node.src_infos)
		else:
			exhausted_body := self._preorder(node.exhausted_body)

		if node.broken_body is null:
			broken_body := ITree::IVar.new("null", node.src_infos)
		else:
			broken_body := self._preorder(node.broken_body)
		
		return self._qq("IFor", [condition, body, exhausted_body, broken_body], node.src_infos)
		


	//
	// This traversal node is a little different than it may first appear. It is not intended to
	// proecss *every* IInsert node; it is only intended to process IInsert's which are used as
	// bog-standard expressions.
	//
	// When IInsert's are used in other places (e.g. in expression bodies (where they can return
	// a single IExpr or a list of IExpr's) or in function parameters etc.) the IInsert should be
	// handled separately.
	//

	func _t_iinsert(self, node):
	
		return self._lift_func_call(_insert_check, [node.expr, Lift::lift(node.src_infos)], node.src_infos)



	func _t_istandard_quasi_quotes(self, node):
	
		return self._preorder(QQ_Mode.new().generate(self, node))



	func _t_imod_id_import(self, node):
	
		return self._qq("IMod_Id_Import", [ITree::IString.new(node.module_id, node.src_infos)], node.src_infos)




////////////////////////////////////////////////////////////////////////////////////////////////////
// Functions called from quasi-quoted generated code
//
// These functions are only called via _lift_func_call.
//

//
// When we evaluate an expression block inside a quasi-quotes, we treat a list of length 1 as if it
// was a single item. This may seem a bit like magic, but works "as you'd expect" in practice.
//

func _expr_block_magic(exprs):

	if Builtins::List.instantiated(exprs) & exprs.len() == 1:
		return exprs[0]
	else:
		return exprs



//
// Insertions in expression blocks can return either a single expression, or a list of expressions.
// Furthermore it's acceptable for any of these expressions to be a pass statement (which wouldn't
// normally count as an expression).
//

func _expr_block_insert(expr, src_infos):

	if Builtins::List.instantiated(expr):
		for e := expr.iterate():
			if not ITree::IPass.instantiated(e):
				ITree_TC::tc_expr(e, "in expression body", src_infos)
	else:
		if not ITree::IPass.instantiated(expr):
			ITree_TC::tc_expr(expr, "in expression body", src_infos)

	return expr



//
// For inserts that are used as bog-standard expressions, check that expr is a valid expression.
//

func _insert_check(expr, src_infos):

	ITree_TC::tc_expr(expr, "in expression", src_infos)
	
	return expr



//
// Check that 'name' is valid for a class name.
//

func _class_name(name, src_infos):

	if not Builtins::String.instantiated(name):
		ITree_TC::type_error("Class_Def", "name", name, "String", src_infos)

	return name



//
// Check that 'name' is valid for a function name.
//

func _func_name(name, src_infos):

	if not Builtins::String.instantiated(name):
		ITree_TC::type_error("Func_Def", "name", name, "String", src_infos)

	return name
