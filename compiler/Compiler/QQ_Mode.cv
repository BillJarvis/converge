// Copyright (c) 2003-2006 King's College London, created by Laurence Tratt
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.


import Builtins, Strings
import CEI, Compiler_Vars, ITree




_QQ_STANDARD := 0
_QQ_DEFINITION := 1




class QQ_Mode:

	func generate(parent_mode, node):
	
		self.parent_mode := parent_mode
		
		// 'closures' is exactly as in Bytecode_Gen; see that file for descriptions of
		// them.
		
		self.closures := []
		
		// These next two slots are purely for convenience.

		self._compiler := CEI::compiler()
		self._module_id := self._compiler.module_id
		
		if ITree::IStandard_Quasi_Quotes.instantiated(node):
			self._type := _QQ_STANDARD

			// To build up a normal quasi-quotes statement we construct a conjunction whose first
			// elements safeguard variables bound in the quasi-quotes, and whose last element(s)
			// construct the ITree itself.
			//
			// e.g.
			//
			//   [|
			//     x := 2
			//     Sys.println(x)
			//   |]
			//
			// gets converted to something along the lines of:
			//
			//   $$qq$$x$$ := CEI::fresh_name("x") | [CEI.iassignment(..., [CEI::ivar($$qq$$x$$)],
			//     CEI::iint(2)), CEI::iapplication(CEI::islot_lookup(CEI::ivar("Sys"), "println"),
			//     [CEI::ivar($$qq$$x$$)])]

			return_exprs := []
			
			if not node.extra_src_infos is null:
				self._extra_src_infos_var := ITree::IVar.new(node.extra_src_infos_var_name, node.src_infos)
				return_exprs.append(ITree::IAssignment.new(ITree::STD_ASSIGN, [self._extra_src_infos_var], node.extra_src_infos, node.src_infos))
			else:
				self._extra_src_infos_var := null

			vars := Set{}
			for var := node.body.exprs.iterate():
				vars.extend(var.qq_bound_vars)
			self._add_vars(vars, [])
			
			// We now do the $$qq$x$$ := CEI::fresh_name("x") constrution.
			//
			// Note that it might seem unsafe to do things in this fashion, since two consecutive
			// quasi-quotes could use the same $$qq$$...$$ name. e.g.:
			//
			//   [| x := 2 |]
			//
			//   [| x := 3 |]
			//
			// The two x's might "clash" and there may be a chance to trick the VM into using a
			// previous value of $$qq$$x$$ instead of giving an unused variable error. In fact,
			// this isn't a problem because QQ_Mode guarantees to initialise all $$qq$$..$$
			// variables each time it constructs an ITree. One can view the reuse of the $$qq$$x$$
			// variable above as an optimisation (although that is perhaps making a virtue out of
			// a very convenient necessity).
			
			for var_name := node.qq_bound_vars.iterate():
				if not node.extra_src_infos is null & var_name == node.extra_src_infos_var_name:
					continue
				
				qq_bound_var := ITree::IVar.new(var_name, node.src_infos)
				fresh_name_func := self._get_module_def_at_qq("Compiler_Vars", "fresh_name", node.src_infos)
				fresh_name := ITree::IApplication.new(fresh_name_func, [ITree::IString.new(var_name, node.src_infos)], node.src_infos)
				return_exprs.append(ITree::IAssignment.new(ITree::STD_ASSIGN, [qq_bound_var], fresh_name, node.src_infos))

			exprs := []
			for expr := node.body.exprs.iterate():
				exprs.append(self._preorder(expr))

			// We don't strictly need to pop the last lot of variables, but do so for completeness.
			
			self._pop_vars()		

			if exprs.len() == 1:
				return_exprs.append(exprs[0])
			else:
				return_exprs.append(ITree::IList.new(exprs, node.src_infos))

			return ITree::IConjunction.new(return_exprs, node.src_infos)
		else:
			raise "XXX"



	func _add_vars(vars, renames):
	
		vars_dict := Dict{}
		for var := vars.iterate():
			vars_dict[var] := vars_dict.len()

		self.closures.append([vars_dict, renames])



	func _pop_vars():
	
		self.closures.del(-1)



	func _qq_bound_var_name(var_name):
	
		return Strings::format(Compiler_Vars::QUASI_QUOTES_NAME, var_name)
	
	
	
	func _qq(node_type, args, node_src_infos):

		src_infos := []
		for src_file, src_offset := node_src_infos.iterate():
			src_infos.append(ITree::IList.new([ITree::IString.new(src_file, node_src_infos), ITree::IInt.new(src_offset, node_src_infos)], node_src_infos))
		
		full_src_infos := ITree::IList.new(src_infos, node_src_infos)
		if not self._extra_src_infos_var is null:
			full_src_infos := ITree::IBinary.new(ITree::BINARY_ADD, full_src_infos, self._extra_src_infos_var, node_src_infos)

		itree_node := ITree::ISlot_Lookup.new(self._get_module_def_at_qq("ITree", node_type, node_src_infos), "new", node_src_infos)
		return ITree::IApplication.new(itree_node, args + [full_src_infos], node_src_infos)



	func _get_var_offset(var_name, src_infos):

		mode := self
		while not mode is null:
			i := mode.closures.len() - 1
			search_var_name := var_name
			while i >= 0:
				if mode.closures[i][Compiler_Vars::CLOSURE_VARS].find(search_var_name):
					break
				if rename_as := mode.closures[i][Compiler_Vars::CLOSURE_RENAMES].find(search_var_name):
					search_var_name := rename_as
				i -= 1
			broken:
				return [search_var_name, mode, i]
			
			mode := mode.parent_mode
		exhausted:
			self._compiler.error(Strings::format("Unknown variable '%s'.", var_name), src_infos)



	func _process_lookup_var(var_name, node_src_infos):

		renamed_var_name, mode, i := self._get_var_offset(var_name, node_src_infos)
		
		if not mode is self:
			// This variable is outside of the quasi-quotes.
			if mode.parent_mode is null & i == 0:
				return self._qq("IOriginal_Name", [ITree::IString.new(self._module_id, node_src_infos), ITree::IString.new(renamed_var_name, node_src_infos)], node_src_infos)
			else:
				self._compiler.error(Strings::format("Trying to reference variable '%s' which is not defined in the outer-most scope.", var_name), node_src_infos)
		
		assert(var_name == renamed_var_name)
		
		return self._qq("IVar", [ITree::IVar.new(self._qq_bound_var_name(var_name), node_src_infos)], node_src_infos)



	func _process_assign_var(var_name, node_src_infos):

		renamed_var_name, mode, i := self._get_var_offset(var_name, node_src_infos)
		
		if not mode is self:
			raise "XXX"

		assert(var_name == renamed_var_name)
		
		return self._qq("IVar", [ITree::IVar.new(self._qq_bound_var_name(var_name), node_src_infos)], node_src_infos)
	
	
	
	//
	// Return an IOriginal_Name which looks up 'defn_name' in the module named 'module_name' in the
	// Converge compiler.
	//
	
	func _get_module_def_at_qq(module_name, defn_name, src_infos):
	
		if not module_id, import_extras := self._compiler.find_import_location(["Compiler", module_name]):
			raise "XXX"
				
		if import_extras.len() > 0:
			raise "XXX"
		
		return ITree::IOriginal_Name.new(module_id, defn_name, src_infos)
		


	/////////////////////////////////////////////////////////////////////////////////////////////////
	// Node traversal
	//

	func _preorder(node):
	
		return self.get_slot("_t_" + node.instance_of.name.to_lower_case())(node)



	func _t_ifunc_def(node):

		self._add_vars(node.internal_bound_vars, [])
	
		is_bound := ITree::IInt.new(node.is_bound, node.src_infos)
		if ITree::IInsert.instantiated(node.func_name):
			// Function names are a little odd because the function "name" is also used as a variable
			// to be assigned to. The function name is actually just the string part of this variable
			// name, which means we have to manually pluck it out. If the user gives us a variable
			// which isn't of type IVar, they would get an odd error message along the lines of
			// "1 doesn't have a func_name slot" which wouldn't really help them track things down.
			// To cope with this eventuality, we put a manual check in that catches such an error
			// at the earliest possible stage.
			func_name := [<node.src_infos>|
				func () {
					func_name := ${self._preorder(node.func_name)}

					if not ITree::IVar.instantiated(func_name):
						raise Compiler_Vars::Compiler_Exception.new(Strings::format("In function node, got %s type for name instead of IVar.", func_name.instance_of.name))

					return func_name.var_name
				}()
			|]
		else:
			func_name := ITree::IString.new(node.func_name, node.src_infos)
			
		params_list := []
		for param := node.params.iterate():
			if ITree::IParam.instantiated(param):
				raise "XXX"
			else:
				assert ITree::IInsert.instantiated(param)
				params_list.append(self._preorder(param))
		
		params := ITree::IApplication.new(ITree::ISlot_Lookup.new(ITree::IList.new(params_list, node.src_infos), "flattened", node.src_infos), [], node.src_infos)
		
		if node.var_arg is null:
			var_arg := ITree::IVar.new("null", node.src_infos)
		elif ITree::IInsert.instantiated(node.var_arg):
			var_arg := self._preorder(node.var_arg)
		else:
			var_arg := self._process_assign_var(node.var_arg.var_name, node.src_infos)
		
		nonlocals := []
		for nonlocal_ := node.nonlocals.iterate():
			raise "XXX"
		
		renames := []
		for rename_ := node.renames.iterate():
			raise "XXX"
		
		body := self._preorder(node.body)
		
		self._pop_vars()
		
		return self._qq("IFunc_Def", [is_bound, func_name, params, var_arg, ITree::IList.new(nonlocals, node.src_infos), ITree::IList.new(renames, node.src_infos), body], node.src_infos)



	func _t_iexpr_block(node):
	
		block := []
		contains_iinsert := 0
		for expr := node.exprs.iterate():
			if ITree::IInsert.instantiated(expr):
				contains_iinsert := 1
			block.append(self._preorder(expr))
		
		list := ITree::IList.new(block, node.src_infos)
		if contains_iinsert == 1:
			exprs := ITree::IApplication.new(ITree::ISlot_Lookup.new(list, "flattened", node.src_infos), [], node.src_infos)
		else:
			exprs := list

		return self._qq("IExpr_Block", [exprs], node.src_infos)



	func _t_iif(node):

		clauses := []
		for clause := node.clauses.iterate():
			clauses.append(self._preorder(clause))
		
		if node.else_body is null:
			else_body := ITree::IVar.new("null", node.src_infos)
		else:
			else_body := self._preorder(node.else_body)
		
		return self._qq("IIf", [ITree::IList.new(clauses, node.src_infos), else_body], node.src_infos)



	func _t_indif(node):

		clauses := []
		for clause := node.clauses.iterate():
			clauses.append(self._preorder(clause))
		
		return self._qq("INDIf", [ITree::IList.new(clauses, node.src_infos)], node.src_infos)



	func _t_iclause(node):
	
		return self._qq("IClause", [self._preorder(node.condition), self._preorder(node.body)], node.src_infos)



	func _t_iint(node):

		return self._qq("IInt", [node], node.src_infos)



	func _t_ivar(node):

		return self._process_lookup_var(node.var_name, node.src_infos)



	func _t_istring(node):

		return self._qq("IString", [node], node.src_infos)



	func _t_islot_lookup(node):

		return self._qq("ISlot_Lookup", [self._preorder(node.object_expr), ITree::IString.new(node.slot_name, node.src_infos)], node.src_infos)



	func _t_imodule_lookup(node):

		if ITree::IInsert.instantiated(node.def_name):
			def_name := self._preorder(node.def_name)
		else:
			def_name := ITree::IString.new(node.def_name, node.src_infos)

		return self._qq("IModule_Lookup", [self._preorder(node.object_expr), def_name], node.src_infos)



	func _t_ilist(node):

		elems := []
		for elem := node.elements.iterate():
			elems.append(self._preorder(elem))
		
		return self._qq("IList", [ITree::IList.new(elems, node.src_infos)], node.src_infos)



	func _t_iapplication(node):

		func_expr := self._preorder(node.func_expr)
		args := []
		for arg := node.args.iterate():
			args.append(self._preorder(arg))
		
		return self._qq("IApplication", [func_expr, ITree::IList.new(args, node.src_infos)], node.src_infos)



	func _t_iget(node):
		
		return self._qq("IGet", [self._preorder(node.get_object), self._preorder(node.index)], node.src_infos)



	func _t_islice(node):

		slice_object := self._preorder(node.slice_object)
		
		if node.lower_bound is null:
			lower_bound := ITree::IVar.new("null", node.src_infos)
		else:
			lower_bound := self._preorder(node.lower_bound)
		
		if node.upper_bound is null:
			upper_bound := ITree::IVar.new("null", node.src_infos)	
		else:
			upper_bound := self._preorder(node.upper_bound)
			
		return self._qq("ISlice", [slice_object, lower_bound, upper_bound], node.src_infos)



	func _t_ireturn(node):
	
		return self._qq("IReturn", [self._preorder(node.return_expr)], node.src_infos)



	func _t_iyield(node):
	
		return self._qq("IYield", [self._preorder(node.yield_expr)], node.src_infos)



	func _t_iraise(node):
	
		return self._qq("IRaise", [self._preorder(node.raise_expr)], node.src_infos)



	func _t_iconjunction(node):
	
		exprs := []
		for expr := node.exprs.iterate():
			exprs.append(self._preorder(expr))
		
		return self._qq("IConjunction", [ITree::IList.new(exprs, node.src_infos)], node.src_infos)



	func _t_iassignment(node):

		targets := []
		for target := node.targets.iterate():
			if ITree::IVar.instantiated(target):
				targets.append(self._process_assign_var(target.var_name, target.src_infos))
			else:
				targets.append(self._preorder(target))

		return self._qq("IAssignment", [ITree::IInt.new(node.type, node.src_infos), ITree::IList.new(targets, node.src_infos), self._preorder(node.expr)], node.src_infos)



	func _t_inot(node):
	
		return self._qq("INot", [self._preorder(node.expr)], node.src_infos)



	func _t_ibinary(node):
	
		return self._qq("IBinary", [ITree::IInt.new(node.type, node.src_infos), self._preorder(node.lhs), self._preorder(node.rhs)], node.src_infos)



	func _t_icomparison(node):
	
		return self._qq("IComparison", [ITree::IInt.new(node.type, node.src_infos), self._preorder(node.lhs), self._preorder(node.rhs)], node.src_infos)



	func _t_ipass(node):
	
		return self._qq("IPass", [], node.src_infos)



	func _t_iimport(node):
	
		raise "XXX"
		return self._qq("IImport", [ITree::IString.new(node.module_path, node.src_infos), ITree::IString.new(node.var_name, node.src_infos)], node.src_infos)





	func _t_iinsert(node):
	
		return node.expr



	func _t_istandard_quasi_quotes(node):
	
		return self._preorder(QQ_Mode.new().generate(self, node))
