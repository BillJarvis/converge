// Copyright (c) 2003-2006 King's College London, created by Laurence Tratt
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.


import Builtins, Exceptions, File, Parse_Options, Platform::Properties, Strings, Sys, Time, VM
import Compiler::Bytecode_Gen, Compiler::Compiler_Vars, Compiler::CV_Exec, Compiler::CV_Library, Compiler::CV_Module, Compiler::CV_Parser, Compiler::IModule_Gen, Compiler::Link, Compiler::Targets, Compiler::Tokenizer




class Compiler:

	////////////////////////////////////////////////////////////////////////////////////////////////
	// Compiler start up
	//

	func from_cmd_line(self):
	
		start_includes := []
	
		options := Parse_Options::Options.new(self._usage_callback)
		options.add(Parse_Options::Option_Spec.new("output", "o", Parse_Options::MANDATORY, Parse_Options::TYPE_ANY, Parse_Options::FREQUENCY_ZERO_OR_ONE))
		options.add(Parse_Options::Option_Spec.new("bootstrap", "b", Parse_Options::NONE, Parse_Options::TYPE_ANY, Parse_Options::FREQUENCY_ZERO_OR_ONE))
		options.add(Parse_Options::Option_Spec.new("includes", "I", Parse_Options::MANDATORY, Parse_Options::TYPE_ANY, Parse_Options::FREQUENCY_ZERO_OR_MORE))
		options.add(Parse_Options::Option_Spec.new("make", "m", Parse_Options::NONE, Parse_Options::TYPE_ANY, Parse_Options::FREQUENCY_ZERO_OR_ONE))
		options.add(Parse_Options::Option_Spec.new("optimise", "O", Parse_Options::NONE))
		options.add(Parse_Options::Option_Spec.new("target", "T", Parse_Options::MANDATORY, Parse_Options::TYPE_ANY, Parse_Options::FREQUENCY_ZERO_OR_ONE))
		options.add(Parse_Options::Option_Spec.new("verbose", "v", Parse_Options::NONE, Parse_Options::TYPE_ANY, Parse_Options::FREQUENCY_ZERO_OR_MORE))
		
		self.bootstrap := 0
		self.mk_mode := 0
		self.output_path := null
		self.start_includes := []
		self.verbosity := 0
		target_name := Strings::format("%dbit", Properties::word_bits)
		internal_target_name := Strings::format("%dbit", Properties::word_bits)
		parsed, extra := options.parse()
		for option_name, option_val := parsed.iter():
			ndif option_name == "output":
				self.output_path := option_val
			elif option_name == "bootstrap":
				self.bootstrap := 1
			elif option_name == "includes":
				self.start_includes.extend(option_val)
			elif option_name == "make":
				self.mk_mode := 1
			elif option_name == "target":
				target_name := option_val
			elif option_name == "verbose":
				self.verbosity += 1

		if extra.len() == 0:
			self._usage_callback("Not enough arguments.")
		elif extra.len() > 1:
			self._usage_callback("Too many arguments.")

		if self.output_path is null:
			if self.mk_mode == 1:
				main, ext := File::split_ext(extra[0])
				if ext != Compiler_Vars::CV_EXTENSION:
					self._usage_callback(Strings::format("-o can not be left out if input file does not end in '.%s'.", Compiler_Vars::CV_EXTENSION))
				if File::exists(main):
					// If there already exists a file with the name we want to write to, check that
					// it really is a Converge executeable. If it isn't, we refuse to carry on.
					file := File::open(main, "r")
					if not file.read(1024).find(CV_Exec::EXEC_INIT_STRING):
						self._usage_callback(Strings::format("-o can not be left out as '%s' can not be overwritten as it does not appear to be a Converge executeable.", main))
					file.close()
				self.output_path := main
			else:
				self._usage_callback("-o option must be specified.")

		self.target := self._target_name_to_target(target_name)
		self.internal_target := self._target_name_to_target(internal_target_name)

		if self.bootstrap == 1:
			// We're in bootstrapping mode. We now have to do some fun stuff with module identifiers.
			//
			// The first thing we need to know is that module ids are based on the fully
			// canonicalised pathname of the corresponding .cv file.
			//
			// The basic problem is quite subtle. The bootstrap compiler contains references to "old"
			// module ids (i.e. old pathnames). Because of e.g. quasi-quotes, some of these old
			// module ids can "leak" into the new output. This then means that the output of the
			// compiler contains invalid module ids which can lead to linker or import errors.
			//
			// In bootstrapping mode we therefore have to carefully convert (sometimes one way,
			// sometimes the other) between old and new module ids to ensure that the running
			// compiler is only dealing with old module ids, but that the output contains only new
			// module ids.
			
			existing_mod_ids := []
			for mod_id := VM::vm.modules.iter_keys():
				if not Compiler_Vars::BUILTIN_MODULES.find(mod_id):
					existing_mod_ids.append(mod_id)
			
			self._orig_bs_path := Strings::lcp(existing_mod_ids)
			if self._orig_bs_path.len() == 0:
				// Sanity check failed.
				raise "XXX"
		
			self._bs_path := File::canon_path(File::join_names(File::split_leaf(Sys::program_path)[0], ".."))
			
			imodule_cv_path := File::canon_path(File::join_names(self._bs_path, "compiler", "Compiler", "IModule_Gen.cv"))
			if not File::exists(imodule_cv_path) | not imodule_cv_path[ : self._bs_path.len()] == self._bs_path:
				// Sanity checks failed.
				raise "XXX"
			
			// XXX This next bit is decidedly dodgy, but there's no obviously better way of doing it
			// that doesn't involve CTMP. Basically we try and work out if the original mod_ids are
			// separated by / or \. This should work OK on the platforms we currently support, but
			// has obvious problems on platforms that use a different directory separator.
			
			if not backslash := self._orig_bs_path.rfind_index("\\"):
				backslash := -1

			if not fwdslash := self._orig_bs_path.rfind_index("/"):
				fwdslash := -1
			
			if backslash > fwdslash:
				self._orig_bs_dir_sep := "\\"
			else:
				self._orig_bs_dir_sep := "/"
			
			VM::set_bootstrap_compiler(self)

		if self.mk_mode == 1:
			self._make(extra[0])
		else:
			cv_module := self._compile_path(extra[0])
			output_file := File::File.new(self.output_path, "w")
			output_file.write(cv_module.serialize())
			output_file.close()



	func from_mk_mode(self, src_path, start_includes, verbosity, target, internal_target, mk_done_cv_mods, mk_mtime_map):

		self.bootstrap := 0
		self.mk_mode := 1
		self.output_path := null
		self.start_includes := start_includes
		self.verbosity := verbosity
		self.target := target
		self.internal_target := internal_target
		
		self.mk_done_cv_mods := mk_done_cv_mods

		cv_mod := self._compile_path(src_path)
		self._write_cache_cvb(src_path, cv_mod.serialize())

		mk_done_cv_mods[src_path] := cv_mod
		mk_mtime_map[src_path] := Time::current()
		
		return cv_mod



	////////////////////////////////////////////////////////////////////////////////////////////////
	// "Public" functions
	//


	func error(self, msg, src_infos := null):
	
		self._print_msg("Error", msg, src_infos)
		Sys::exit(1)



	func warning(self, msg, src_infos := null):
	
		self._print_msg("Warning", msg, src_infos)



	func info(self, msg):
	
		Sys::stderr.writeln(Strings::format("===> %s%s", " " * ((Compiler_Vars::num_compilers() - 1) * 2), msg))



	func get_cv_mod(self, src_path, src_infos := null):
	
		if cv_mod, mtime := self._read_cache_cvb(src_path):
			return cv_mod

		if self.mk_mode == 0:
			self.error(Strings::format("Can not find compiled version of '%s'.", src_path), src_infos)
		
		if cv_mod := self.mk_done_cv_mods.find(src_path):
			return cv_mod
	
		compiler := Compiler.new()
		Compiler_Vars::push_compiler(compiler)
		cv_mod := compiler.from_mk_mode(src_path, self.start_includes, self.verbosity, self.target, self.internal_target, self.mk_done_cv_mods, self.mk_mtime_map)
		Compiler_Vars::pop_compiler()
		
		if self.verbosity > 0:
			self.info(Strings::format("Returning to compile of %s...", self.mod_id))

		return cv_mod



	func find_import_location(self, import_name_list):

		func match_path(i, dir):
		
			cnd_path := File::join_names(dir, import_name_list[i])

			if File::exists(cnd_path) & File::is_dir(cnd_path):
				if i + 1 == import_name_list.len():
					return [cnd_path, i]
				else:
					return match_path(i + 1, cnd_path)

			cnd_file_path := File::join_ext(cnd_path, CV_Module::CV_EXTENSION)
			if File::exists(cnd_file_path) & File::is_file(cnd_file_path):
				return [cnd_file_path, i]
			
			fail
			
	
		for include_dir := self.includes.iter():
			if matched_path, extra_pos := match_path(0, include_dir):
				import_full_name := File::canon_path(matched_path)
				import_extras := import_name_list[extra_pos + 1 : ]
				break
		exhausted:
			// If the first part of the import references a builtin, then looking up that module ID
			// will succeed.
			if VM::find_module(import_name_list[0]):
				import_full_name := import_name_list[0]
				import_extras := import_name_list[1 : ]
			else:
				fail
		
		return [import_full_name, import_extras]



	func mod_id_to_new(self, mod_id):
	
		assert(self.bootstrap == 1)
		
		if not mod_id.prefixed_by(self._orig_bs_path):
			return mod_id
		
		new_mod_id := File::join_names(self._bs_path, mod_id[self._orig_bs_path.len() : ])
		new_mod_id := new_mod_id.replaced(self._orig_bs_dir_sep, File::DIR_SEP)
		
		return new_mod_id



	func mod_id_to_old(self, mod_id):
	
		assert(self.bootstrap == 1)
		
		if not mod_id.prefixed_by(self._bs_path):
			return mod_id
		
		old_mod_id := File::join_names(self._orig_bs_path, mod_id[self._bs_path.len() : ])
		old_mod_id := old_mod_id.replaced(File::DIR_SEP, self._orig_bs_dir_sep)
		
		return old_mod_id



	////////////////////////////////////////////////////////////////////////////////////////////////
	// Internal functions
	//


	func _compile_path(self, src_path):

		self.includes := self.start_includes

		if not File::exists(src_path):
			self.error(Strings::format("Source file '%s' not found.", src_path))

		if self.verbosity > 0:
			self.info(Strings::format("Compiling %s...", src_path))

		self.mod_id := File::canon_path(src_path)

		if (input_file_dir := File::split_leaf(self.mod_id)[0]) == "":
			self.includes.insert(0, ".")
		else:
			self.includes.insert(0, input_file_dir)

		// For the moment, we assume the compiled module name is simply the leaf name (minus its
		// extension). On platforms with non-case preserving filesystems, perhaps there is a need
		// for a more sophisticated mechanism?

		self.src_module_name := File::split_ext(File::split_leaf(self.mod_id)[1])[0]

		self.includes.extend(Compiler_Vars::find_std_includes())

		src_file := File::open(self.mod_id, "r")
		src_data := src_file.read()
		src_file.close()

		self.tokenizer := Tokenizer::Tokenizer.new()
		parse_tree := CV_Parser::parse(src_data)
		self.newlines := self.tokenizer.newlines

		imodule := IModule_Gen::IModule_Gen.new().gen(parse_tree)
		
		bc := Bytecode_Gen::Bytecode_Gen.new().generate(imodule, self.target)
		
		if self.verbosity > 0:
			self.info(Strings::format("Finished compiling %s.", src_path))
		
		return bc



	//
	// Compile 'src_path', and its dependencies, in a make-like fashion.
	//

	func _make(self, src_path):

		// This function has more to it than it might first appear. The basic strategy is this: we
		// compile the given module and all its obvious imports. Life becomes trickier because of
		// CTMP. This means that when we're half way through compiling x.cv, we realise we need
		// to compile y.cv in order that x.cv can execute CTMP. This means that we have to start
		// up sub-compiler(s).

		if File::exists(self.output_path):
			if File::mtime(self.output_path) < File::mtime(src_path):
				do_link := 1
			else:
				do_link := 0
		else:
			do_link := 1

		main_mod_id := File::canon_path(src_path)
		self.mk_done_cv_mods := Dict{main_mod_id : null} // module id : CV_Module instances map.

		// We want to ensure that we never try to compile any of the stuff in the builtin libraries,
		// so read these in to make sure this doesn't happen.
		
		lib_mods := []
		lib_mod_ids := Set{}
		for lib_path := Compiler_Vars::get_std_libraries().iter():
			lib := CV_Library::CV_Library.new(self.target)
			lib_file := File::open(lib_path, "r")
			lib_data := lib_file.read()
			lib_file.close()
			for cv_mod := lib.deserialize(lib_data).iter():
				lib_mods.append(cv_mod)
				lib_mod_ids.add(cv_mod.get_mod_id())
				self.mk_done_cv_mods[cv_mod.get_mod_id()] := cv_mod

		// The main loop. Basically we keep on going around this, reading in cached files or
		// compiling new files; and updating any modules who are older than their import
		// dependencies to ensure that any CTMP works on the latest version of the module available.
		// Assuming there are no circular imports this will eventually hit a fixed point (possibly
		// having compiled the same module multiple times), and the loop is finished. Although this
		// is not as efficient as a customised Makefile with static dependencies could be, it is
		// easier to use and is (hopefully) guaranteed to make sure everything is upto date.

		main_mod := null
		self.mk_mtime_map := Dict{} // module id : mtime

		while 1:
			again := 0 // Set to 1 to force another round of the loop.
			for mod_id, cv_mod := self.mk_done_cv_mods.iter():
				if lib_mod_ids.find(mod_id):
					continue
				
				compile := 0
				if cv_mod is null:
					// We haven't previously encountered this module, so try seeing if we can read in
					// a cached version.
					if cv_mod, mtime := self._read_cache_cvb(mod_id):
						mod_id := cv_mod.get_mod_id()
						self.mk_done_cv_mods[mod_id] := cv_mod
						self.mk_mtime_map[mod_id] := mtime
					else:
						compile := 1
				
				if not cv_mod is null:
					// We check to see whether this module is "stale" i.e. is older than any of its
					// import dependencies.
					assert(mod_id == cv_mod.get_mod_id())
					mtime := self.mk_mtime_map[mod_id]
					for imp_mod_id := cv_mod.get_imports().iter():
						if Compiler_Vars::BUILTIN_MODULES.find(imp_mod_id):
							continue

						if File::is_dir(imp_mod_id):
							// This must be a package. We therefore expand things so that this module
							// is dependent on all the packages sub-modules. We could be more
							// efficient about this by only depending on the package modules that
							// this module uses.
							imp_mod_ids := self._locate_cv_files(imp_mod_id)
						else:
							imp_mod_ids := [imp_mod_id]
						
						for cnd_mod_id := imp_mod_ids.iter():
							if not self.mk_done_cv_mods.find(cnd_mod_id):
								self.mk_done_cv_mods[cnd_mod_id] := null
								again := 1
								continue

							if mtime < self.mk_mtime_map.find(cnd_mod_id):
								compile := 1
				
				if compile == 1:
					// Compilation has been forced.
					cv_mod := self._compile_path(mod_id)
					self._write_cache_cvb(mod_id, cv_mod.serialize())
					self.mk_done_cv_mods[mod_id] := cv_mod
					self.mk_mtime_map[mod_id] := Time::current()
					again := 1
					do_link := 1
					
				if mod_id == main_mod_id:
					main_mod := cv_mod

			if again == 0:
				break
		
		// Everything is compiled. If anything has been updated, then we need to link things.
		
		if do_link == 1:
			// Create the list of modules to link, including all library modules.
			link_mods := [main_mod]
			for mod := self.mk_done_cv_mods.iter_vals():
				if not mod is main_mod:
					link_mods.append(mod)
			link_mods.extend(lib_mods)

			if self.verbosity > 0:
				self.info("Linking.")
			self.mod_id := link_mods[0].get_mod_id()
			ser_cv_exec := Linker.new().link(link_mods, self.target)

			output_file := File::File.new(self.output_path, "w")
			output_file.write(ser_cv_exec)
			output_file.close()
			try:
				File::chmod(self.output_path, 493)
			catch Exceptions::File_Exception:
				pass



	func _usage_callback(self, msg):
	
		if not msg is null:
			Sys::stderr.writeln(Strings::format("Error: %s", msg))
		Sys::stderr.writeln("Usage: convergec [-bm] [-I <include> [-I <include> ...]] [-O] [-T <target bit size>] -o <output> <input>")
		if not msg is null:
			Sys::exit(1)



	func _print_msg(self, pre_msg, msg, src_infos := null):
	
		if not src_infos is null:
			assert src_infos.len() > 0

			// If any of the src infos reference a file other than the one being specified, then
			// other_files will be set to 1. This then changes the way we format error messages.

			other_files := 0
			for src_info := src_infos.iter():
				if src_info[0] != self.mod_id:
					other_files := 1
					break

			if src_infos.len() == 1 & other_files == 0:
				Sys::stderr.write(Strings::format("%s: ", pre_msg))
			else:
				Sys::stderr.writeln(Strings::format("%s:", pre_msg))

			for src_info := src_infos.iter():
				if src_info[0] == self.mod_id:
					src_offset := src_info[1]
					newlines := self.tokenizer.newlines
					line := 0
					while line < newlines.len():
						if src_offset < newlines[line]:
							break
						line += 1
					col := src_offset - newlines[line - 1]
				else:
					if not mod := VM::find_module(src_info[0]):
						raise "XXX"
					line, col := mod.src_offset_to_line_column(src_info[1])
				
				if src_infos.len() == 1 & other_files == 0:
					Sys::stderr.write(Strings::format("Line %d, column %d: ", line, col))
				else:
					if other_files == 0:
						Sys::stderr.writeln(Strings::format("  Line %d, column %d", line, col))
					else:
						Sys::stderr.writeln(Strings::format("  %s, line %d, column %d", src_info[0], line, col))

			Sys::stderr.writeln(msg)
		else:
			Sys::stderr.writeln(Strings::format("%s: %s", pre_msg, msg))
					


	func _target_name_to_target(self, target_name):

		if not Targets::Available::TARGETS.find(target_name):
			self.error(Strings::format("No support yet for target '%s'.", target_name))

		return Targets::Available::TARGETS[target_name].new()



	//
	// Attempt to read the bytecode file matching 'src_path' if it exists. If nothing can be read,
	// this method fails.
	//

	func _read_cache_cvb(self, src_path):

		if (cvb_path := Compiler_Vars::cvb_cache_path(src_path)) & File::exists(cvb_path):
			cvb_mtime := File::mtime(cvb_path)
			if cvb_mtime > File::mtime(src_path):
				cvb_file := File::open(cvb_path, "r")
				cvb_data := cvb_file.read()
				cvb_file.close()
				if cvb_data.prefixed_by(CV_Module::MODULE_INIT_STRING):
					mod := CV_Module::CV_Module.new(self.internal_target)
					mod.deserialize_str(cvb_data)
					return [mod, cvb_mtime]
		
		fail



	//
	// Attempt to write the bytecode 'bc' to the correct cached location for the src file 'src_path'.
	// This fails silently if it is unable to do so.
	//

	func _write_cache_cvb(self, src_path, bc):

		if cvb_path := Compiler_Vars::cvb_cache_path(src_path):
			can_write := 1
			if File::exists(cvb_path):
				cvb_file := File::open(cvb_path, "r")
				if cvb_file.read(CV_Module::MODULE_INIT_STRING.len()) != CV_Module::MODULE_INIT_STRING:
					can_write := 0
				cvb_file.close()

			if can_write == 1:
				cvb_file := File::open(cvb_path, "w")
				cvb_file.write(bc)
				cvb_file.close()



	func _locate_cv_files(self, path):
	
		cv_files := []
		for leaf := File::iter_dir_entries(path):
			entry_path := File::join_names(path, leaf)
			if File::is_file(entry_path) & File::split_ext(leaf)[1] == Compiler_Vars::CV_EXTENSION:
				cv_files.append(entry_path)
			elif File::is_dir(entry_path):
				cv_files.extend(self._locate_cv_files(entry_path))
		
		return cv_files




//
// This linker class is used when we're running in make mode only.
//

class Linker:

	func link(self, mods, target):

		self.mods := mods

		return Link::link_exec(mods, self, target)



	func error(self, msg, src_infos := null):

		self.print_msg("Error", msg, src_infos)
		Sys::exit(1)



	func warning(self, msg, src_infos := null):

		self.print_msg("Warning", msg, src_infos)



	func print_msg(self, pre_msg, msg, src_infos := null):

		if not src_infos is null:
			Sys::stderr.writeln(Strings::format("%s:", pre_msg))
			for src_info := src_infos.iter():
				for cv_mod := self.mods.iter():
					if cv_mod.get_mod_id() == src_info[0]:
						break
				exhausted:
					raise "XXX"
				mod := Builtins::Module.new(cv_mod.serialize())
				line, col := mod.src_offset_to_line_column(src_info[1])
				
				Sys::stderr.writeln(Strings::format("  %s, line %d, column %d", src_info[0], line, col))

			Sys::stderr.writeln(msg)
		else:
			Sys::stderr.writeln(Strings::format("%s: %s", pre_msg, msg))




func main():

	compiler := Compiler.new()
	Compiler_Vars::push_compiler(compiler)
	compiler.from_cmd_line()
	Compiler_Vars::pop_compiler()
